/*
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.16.0-alpha1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Camunda.Http.Api.Client.OpenAPIDateConverter;

namespace Camunda.Http.Api.Model
{
    /// <summary>
    /// A Task query which defines a group of Tasks.
    /// </summary>
    [DataContract(Name = "TaskQueryDto")]
    public partial class TaskQueryDto : IEquatable<TaskQueryDto>, IValidatableObject
    {
        /// <summary>
        /// Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum DelegationStateEnum
        {
            /// <summary>
            /// Enum PENDING for value: PENDING
            /// </summary>
            [EnumMember(Value = "PENDING")]
            PENDING = 1,

            /// <summary>
            /// Enum RESOLVED for value: RESOLVED
            /// </summary>
            [EnumMember(Value = "RESOLVED")]
            RESOLVED = 2

        }


        /// <summary>
        /// Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.</value>
        [DataMember(Name = "delegationState", EmitDefaultValue = true)]
        public DelegationStateEnum? DelegationState { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="TaskQueryDto" /> class.
        /// </summary>
        /// <param name="processInstanceId">Restrict to tasks that belong to process instances with the given id..</param>
        /// <param name="processInstanceIdIn">Restrict to tasks that belong to process instances with the given ids..</param>
        /// <param name="processInstanceBusinessKey">Restrict to tasks that belong to process instances with the given business key..</param>
        /// <param name="processInstanceBusinessKeyExpression">Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions..</param>
        /// <param name="processInstanceBusinessKeyIn">Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list..</param>
        /// <param name="processInstanceBusinessKeyLike">Restrict to tasks that have a process instance business key that has the parameter  value as a substring..</param>
        /// <param name="processInstanceBusinessKeyLikeExpression">Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions..</param>
        /// <param name="processDefinitionId">Restrict to tasks that belong to a process definition with the given id..</param>
        /// <param name="processDefinitionKey">Restrict to tasks that belong to a process definition with the given key..</param>
        /// <param name="processDefinitionKeyIn">Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list..</param>
        /// <param name="processDefinitionName">Restrict to tasks that belong to a process definition with the given name..</param>
        /// <param name="processDefinitionNameLike">Restrict to tasks that have a process definition name that has the parameter value as  a substring..</param>
        /// <param name="executionId">Restrict to tasks that belong to an execution with the given id..</param>
        /// <param name="caseInstanceId">Restrict to tasks that belong to case instances with the given id..</param>
        /// <param name="caseInstanceBusinessKey">Restrict to tasks that belong to case instances with the given business key..</param>
        /// <param name="caseInstanceBusinessKeyLike">Restrict to tasks that have a case instance business key that has the parameter value  as a substring..</param>
        /// <param name="caseDefinitionId">Restrict to tasks that belong to a case definition with the given id..</param>
        /// <param name="caseDefinitionKey">Restrict to tasks that belong to a case definition with the given key..</param>
        /// <param name="caseDefinitionName">Restrict to tasks that belong to a case definition with the given name..</param>
        /// <param name="caseDefinitionNameLike">Restrict to tasks that have a case definition name that has the parameter value as a  substring..</param>
        /// <param name="caseExecutionId">Restrict to tasks that belong to a case execution with the given id..</param>
        /// <param name="activityInstanceIdIn">Only include tasks which belong to one of the passed and comma-separated activity  instance ids..</param>
        /// <param name="tenantIdIn">Only include tasks which belong to one of the passed and comma-separated  tenant ids..</param>
        /// <param name="withoutTenantId">Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="assignee">Restrict to tasks that the given user is assigned to..</param>
        /// <param name="assigneeExpression">Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions..</param>
        /// <param name="assigneeLike">Restrict to tasks that have an assignee that has the parameter  value as a substring..</param>
        /// <param name="assigneeLikeExpression">Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions..</param>
        /// <param name="assigneeIn">Only include tasks which are assigned to one of the passed and comma-separated user ids..</param>
        /// <param name="owner">Restrict to tasks that the given user owns..</param>
        /// <param name="ownerExpression">Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions..</param>
        /// <param name="candidateGroup">Only include tasks that are offered to the given group..</param>
        /// <param name="candidateGroupExpression">Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions..</param>
        /// <param name="candidateUser">Only include tasks that are offered to the given user or to one of his groups..</param>
        /// <param name="candidateUserExpression">Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions..</param>
        /// <param name="includeAssignedTasks">Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (default to false).</param>
        /// <param name="involvedUser">Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee)..</param>
        /// <param name="involvedUserExpression">Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions..</param>
        /// <param name="assigned">If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (default to false).</param>
        /// <param name="unassigned">If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (default to false).</param>
        /// <param name="taskDefinitionKey">Restrict to tasks that have the given key..</param>
        /// <param name="taskDefinitionKeyIn">Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list..</param>
        /// <param name="taskDefinitionKeyLike">Restrict to tasks that have a key that has the parameter value as a substring..</param>
        /// <param name="name">Restrict to tasks that have the given name..</param>
        /// <param name="nameNotEqual">Restrict to tasks that do not have the given name..</param>
        /// <param name="nameLike">Restrict to tasks that have a name with the given parameter value as substring..</param>
        /// <param name="nameNotLike">Restrict to tasks that do not have a name with the given parameter value as substring..</param>
        /// <param name="description">Restrict to tasks that have the given description..</param>
        /// <param name="descriptionLike">Restrict to tasks that have a description that has the parameter value as a substring..</param>
        /// <param name="priority">Restrict to tasks that have the given priority..</param>
        /// <param name="maxPriority">Restrict to tasks that have a lower or equal priority..</param>
        /// <param name="minPriority">Restrict to tasks that have a higher or equal priority..</param>
        /// <param name="dueDate">Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;..</param>
        /// <param name="dueDateExpression">Restrict to tasks that are due on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="dueAfter">Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;..</param>
        /// <param name="dueAfterExpression">Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="dueBefore">Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;..</param>
        /// <param name="dueBeforeExpression">Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="withoutDueDate">Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="followUpDate">Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;..</param>
        /// <param name="followUpDateExpression">Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="followUpAfter">Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;..</param>
        /// <param name="followUpAfterExpression">Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="followUpBefore">Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;..</param>
        /// <param name="followUpBeforeExpression">Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="followUpBeforeOrNotExistent">Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date..</param>
        /// <param name="followUpBeforeOrNotExistentExpression">Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="createdOn">Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;..</param>
        /// <param name="createdOnExpression">Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="createdAfter">Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;..</param>
        /// <param name="createdAfterExpression">Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="createdBefore">Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;..</param>
        /// <param name="createdBeforeExpression">Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object..</param>
        /// <param name="delegationState">Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;..</param>
        /// <param name="candidateGroups">Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;..</param>
        /// <param name="candidateGroupsExpression">Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings..</param>
        /// <param name="withCandidateGroups">Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="withoutCandidateGroups">Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="withCandidateUsers">Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="withoutCandidateUsers">Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="active">Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="suspended">Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (default to false).</param>
        /// <param name="taskVariables">A JSON array to only include tasks that have variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters..</param>
        /// <param name="processVariables">A JSON array to only include tasks that belong to a process instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters..</param>
        /// <param name="caseInstanceVariables">A JSON array to only include tasks that belong to a case instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters..</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (default to false).</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (default to false).</param>
        /// <param name="parentTaskId">Restrict query to all tasks that are sub tasks of the given task. Takes a task id..</param>
        /// <param name="orQueries">A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills *at least one* of the query&#39;s predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task query properties can be used except for: &#x60;sorting&#x60;, &#x60;withCandidateGroups&#x60;, &#x60;withoutCandidateGroups&#x60;, &#x60;withCandidateUsers&#x60;, &#x60;withoutCandidateUsers&#x60;  See the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries..</param>
        /// <param name="sorting">Apply sorting of the result.</param>
        public TaskQueryDto(string processInstanceId = default(string), List<string> processInstanceIdIn = default(List<string>), string processInstanceBusinessKey = default(string), string processInstanceBusinessKeyExpression = default(string), List<string> processInstanceBusinessKeyIn = default(List<string>), string processInstanceBusinessKeyLike = default(string), string processInstanceBusinessKeyLikeExpression = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), List<string> processDefinitionKeyIn = default(List<string>), string processDefinitionName = default(string), string processDefinitionNameLike = default(string), string executionId = default(string), string caseInstanceId = default(string), string caseInstanceBusinessKey = default(string), string caseInstanceBusinessKeyLike = default(string), string caseDefinitionId = default(string), string caseDefinitionKey = default(string), string caseDefinitionName = default(string), string caseDefinitionNameLike = default(string), string caseExecutionId = default(string), List<string> activityInstanceIdIn = default(List<string>), List<string> tenantIdIn = default(List<string>), bool? withoutTenantId = false, string assignee = default(string), string assigneeExpression = default(string), string assigneeLike = default(string), string assigneeLikeExpression = default(string), List<string> assigneeIn = default(List<string>), string owner = default(string), string ownerExpression = default(string), string candidateGroup = default(string), string candidateGroupExpression = default(string), string candidateUser = default(string), string candidateUserExpression = default(string), bool? includeAssignedTasks = false, string involvedUser = default(string), string involvedUserExpression = default(string), bool? assigned = false, bool? unassigned = false, string taskDefinitionKey = default(string), List<string> taskDefinitionKeyIn = default(List<string>), string taskDefinitionKeyLike = default(string), string name = default(string), string nameNotEqual = default(string), string nameLike = default(string), string nameNotLike = default(string), string description = default(string), string descriptionLike = default(string), int? priority = default(int?), int? maxPriority = default(int?), int? minPriority = default(int?), DateTimeOffset? dueDate = default(DateTimeOffset?), string dueDateExpression = default(string), DateTimeOffset? dueAfter = default(DateTimeOffset?), string dueAfterExpression = default(string), DateTimeOffset? dueBefore = default(DateTimeOffset?), string dueBeforeExpression = default(string), bool? withoutDueDate = false, DateTimeOffset? followUpDate = default(DateTimeOffset?), string followUpDateExpression = default(string), DateTimeOffset? followUpAfter = default(DateTimeOffset?), string followUpAfterExpression = default(string), string followUpBefore = default(string), string followUpBeforeExpression = default(string), DateTimeOffset? followUpBeforeOrNotExistent = default(DateTimeOffset?), string followUpBeforeOrNotExistentExpression = default(string), DateTimeOffset? createdOn = default(DateTimeOffset?), string createdOnExpression = default(string), DateTimeOffset? createdAfter = default(DateTimeOffset?), string createdAfterExpression = default(string), DateTimeOffset? createdBefore = default(DateTimeOffset?), string createdBeforeExpression = default(string), DelegationStateEnum? delegationState = default(DelegationStateEnum?), List<string> candidateGroups = default(List<string>), string candidateGroupsExpression = default(string), bool? withCandidateGroups = false, bool? withoutCandidateGroups = false, bool? withCandidateUsers = false, bool? withoutCandidateUsers = false, bool? active = false, bool? suspended = false, List<VariableQueryParameterDto> taskVariables = default(List<VariableQueryParameterDto>), List<VariableQueryParameterDto> processVariables = default(List<VariableQueryParameterDto>), List<VariableQueryParameterDto> caseInstanceVariables = default(List<VariableQueryParameterDto>), bool? variableNamesIgnoreCase = false, bool? variableValuesIgnoreCase = false, string parentTaskId = default(string), List<TaskQueryDto> orQueries = default(List<TaskQueryDto>), List<TaskQueryDtoSorting> sorting = default(List<TaskQueryDtoSorting>))
        {
            this.ProcessInstanceId = processInstanceId;
            this.ProcessInstanceIdIn = processInstanceIdIn;
            this.ProcessInstanceBusinessKey = processInstanceBusinessKey;
            this.ProcessInstanceBusinessKeyExpression = processInstanceBusinessKeyExpression;
            this.ProcessInstanceBusinessKeyIn = processInstanceBusinessKeyIn;
            this.ProcessInstanceBusinessKeyLike = processInstanceBusinessKeyLike;
            this.ProcessInstanceBusinessKeyLikeExpression = processInstanceBusinessKeyLikeExpression;
            this.ProcessDefinitionId = processDefinitionId;
            this.ProcessDefinitionKey = processDefinitionKey;
            this.ProcessDefinitionKeyIn = processDefinitionKeyIn;
            this.ProcessDefinitionName = processDefinitionName;
            this.ProcessDefinitionNameLike = processDefinitionNameLike;
            this.ExecutionId = executionId;
            this.CaseInstanceId = caseInstanceId;
            this.CaseInstanceBusinessKey = caseInstanceBusinessKey;
            this.CaseInstanceBusinessKeyLike = caseInstanceBusinessKeyLike;
            this.CaseDefinitionId = caseDefinitionId;
            this.CaseDefinitionKey = caseDefinitionKey;
            this.CaseDefinitionName = caseDefinitionName;
            this.CaseDefinitionNameLike = caseDefinitionNameLike;
            this.CaseExecutionId = caseExecutionId;
            this.ActivityInstanceIdIn = activityInstanceIdIn;
            this.TenantIdIn = tenantIdIn;
            // use default value if no "withoutTenantId" provided
            this.WithoutTenantId = withoutTenantId ?? false;
            this.Assignee = assignee;
            this.AssigneeExpression = assigneeExpression;
            this.AssigneeLike = assigneeLike;
            this.AssigneeLikeExpression = assigneeLikeExpression;
            this.AssigneeIn = assigneeIn;
            this.Owner = owner;
            this.OwnerExpression = ownerExpression;
            this.CandidateGroup = candidateGroup;
            this.CandidateGroupExpression = candidateGroupExpression;
            this.CandidateUser = candidateUser;
            this.CandidateUserExpression = candidateUserExpression;
            // use default value if no "includeAssignedTasks" provided
            this.IncludeAssignedTasks = includeAssignedTasks ?? false;
            this.InvolvedUser = involvedUser;
            this.InvolvedUserExpression = involvedUserExpression;
            // use default value if no "assigned" provided
            this.Assigned = assigned ?? false;
            // use default value if no "unassigned" provided
            this.Unassigned = unassigned ?? false;
            this.TaskDefinitionKey = taskDefinitionKey;
            this.TaskDefinitionKeyIn = taskDefinitionKeyIn;
            this.TaskDefinitionKeyLike = taskDefinitionKeyLike;
            this.Name = name;
            this.NameNotEqual = nameNotEqual;
            this.NameLike = nameLike;
            this.NameNotLike = nameNotLike;
            this.Description = description;
            this.DescriptionLike = descriptionLike;
            this.Priority = priority;
            this.MaxPriority = maxPriority;
            this.MinPriority = minPriority;
            this.DueDate = dueDate;
            this.DueDateExpression = dueDateExpression;
            this.DueAfter = dueAfter;
            this.DueAfterExpression = dueAfterExpression;
            this.DueBefore = dueBefore;
            this.DueBeforeExpression = dueBeforeExpression;
            // use default value if no "withoutDueDate" provided
            this.WithoutDueDate = withoutDueDate ?? false;
            this.FollowUpDate = followUpDate;
            this.FollowUpDateExpression = followUpDateExpression;
            this.FollowUpAfter = followUpAfter;
            this.FollowUpAfterExpression = followUpAfterExpression;
            this.FollowUpBefore = followUpBefore;
            this.FollowUpBeforeExpression = followUpBeforeExpression;
            this.FollowUpBeforeOrNotExistent = followUpBeforeOrNotExistent;
            this.FollowUpBeforeOrNotExistentExpression = followUpBeforeOrNotExistentExpression;
            this.CreatedOn = createdOn;
            this.CreatedOnExpression = createdOnExpression;
            this.CreatedAfter = createdAfter;
            this.CreatedAfterExpression = createdAfterExpression;
            this.CreatedBefore = createdBefore;
            this.CreatedBeforeExpression = createdBeforeExpression;
            this.DelegationState = delegationState;
            this.CandidateGroups = candidateGroups;
            this.CandidateGroupsExpression = candidateGroupsExpression;
            // use default value if no "withCandidateGroups" provided
            this.WithCandidateGroups = withCandidateGroups ?? false;
            // use default value if no "withoutCandidateGroups" provided
            this.WithoutCandidateGroups = withoutCandidateGroups ?? false;
            // use default value if no "withCandidateUsers" provided
            this.WithCandidateUsers = withCandidateUsers ?? false;
            // use default value if no "withoutCandidateUsers" provided
            this.WithoutCandidateUsers = withoutCandidateUsers ?? false;
            // use default value if no "active" provided
            this.Active = active ?? false;
            // use default value if no "suspended" provided
            this.Suspended = suspended ?? false;
            this.TaskVariables = taskVariables;
            this.ProcessVariables = processVariables;
            this.CaseInstanceVariables = caseInstanceVariables;
            // use default value if no "variableNamesIgnoreCase" provided
            this.VariableNamesIgnoreCase = variableNamesIgnoreCase ?? false;
            // use default value if no "variableValuesIgnoreCase" provided
            this.VariableValuesIgnoreCase = variableValuesIgnoreCase ?? false;
            this.ParentTaskId = parentTaskId;
            this.OrQueries = orQueries;
            this.Sorting = sorting;
        }

        /// <summary>
        /// Restrict to tasks that belong to process instances with the given id.
        /// </summary>
        /// <value>Restrict to tasks that belong to process instances with the given id.</value>
        [DataMember(Name = "processInstanceId", EmitDefaultValue = true)]
        public string ProcessInstanceId { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to process instances with the given ids.
        /// </summary>
        /// <value>Restrict to tasks that belong to process instances with the given ids.</value>
        [DataMember(Name = "processInstanceIdIn", EmitDefaultValue = true)]
        public List<string> ProcessInstanceIdIn { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to process instances with the given business key.
        /// </summary>
        /// <value>Restrict to tasks that belong to process instances with the given business key.</value>
        [DataMember(Name = "processInstanceBusinessKey", EmitDefaultValue = true)]
        public string ProcessInstanceBusinessKey { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
        /// </summary>
        /// <value>Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.</value>
        [DataMember(Name = "processInstanceBusinessKeyExpression", EmitDefaultValue = true)]
        public string ProcessInstanceBusinessKeyExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
        /// </summary>
        /// <value>Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.</value>
        [DataMember(Name = "processInstanceBusinessKeyIn", EmitDefaultValue = true)]
        public List<string> ProcessInstanceBusinessKeyIn { get; set; }

        /// <summary>
        /// Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that have a process instance business key that has the parameter  value as a substring.</value>
        [DataMember(Name = "processInstanceBusinessKeyLike", EmitDefaultValue = true)]
        public string ProcessInstanceBusinessKeyLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
        /// </summary>
        /// <value>Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.</value>
        [DataMember(Name = "processInstanceBusinessKeyLikeExpression", EmitDefaultValue = true)]
        public string ProcessInstanceBusinessKeyLikeExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a process definition with the given id.
        /// </summary>
        /// <value>Restrict to tasks that belong to a process definition with the given id.</value>
        [DataMember(Name = "processDefinitionId", EmitDefaultValue = true)]
        public string ProcessDefinitionId { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a process definition with the given key.
        /// </summary>
        /// <value>Restrict to tasks that belong to a process definition with the given key.</value>
        [DataMember(Name = "processDefinitionKey", EmitDefaultValue = true)]
        public string ProcessDefinitionKey { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
        /// </summary>
        /// <value>Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.</value>
        [DataMember(Name = "processDefinitionKeyIn", EmitDefaultValue = true)]
        public List<string> ProcessDefinitionKeyIn { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a process definition with the given name.
        /// </summary>
        /// <value>Restrict to tasks that belong to a process definition with the given name.</value>
        [DataMember(Name = "processDefinitionName", EmitDefaultValue = true)]
        public string ProcessDefinitionName { get; set; }

        /// <summary>
        /// Restrict to tasks that have a process definition name that has the parameter value as  a substring.
        /// </summary>
        /// <value>Restrict to tasks that have a process definition name that has the parameter value as  a substring.</value>
        [DataMember(Name = "processDefinitionNameLike", EmitDefaultValue = true)]
        public string ProcessDefinitionNameLike { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to an execution with the given id.
        /// </summary>
        /// <value>Restrict to tasks that belong to an execution with the given id.</value>
        [DataMember(Name = "executionId", EmitDefaultValue = true)]
        public string ExecutionId { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to case instances with the given id.
        /// </summary>
        /// <value>Restrict to tasks that belong to case instances with the given id.</value>
        [DataMember(Name = "caseInstanceId", EmitDefaultValue = true)]
        public string CaseInstanceId { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to case instances with the given business key.
        /// </summary>
        /// <value>Restrict to tasks that belong to case instances with the given business key.</value>
        [DataMember(Name = "caseInstanceBusinessKey", EmitDefaultValue = true)]
        public string CaseInstanceBusinessKey { get; set; }

        /// <summary>
        /// Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
        /// </summary>
        /// <value>Restrict to tasks that have a case instance business key that has the parameter value  as a substring.</value>
        [DataMember(Name = "caseInstanceBusinessKeyLike", EmitDefaultValue = true)]
        public string CaseInstanceBusinessKeyLike { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a case definition with the given id.
        /// </summary>
        /// <value>Restrict to tasks that belong to a case definition with the given id.</value>
        [DataMember(Name = "caseDefinitionId", EmitDefaultValue = true)]
        public string CaseDefinitionId { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a case definition with the given key.
        /// </summary>
        /// <value>Restrict to tasks that belong to a case definition with the given key.</value>
        [DataMember(Name = "caseDefinitionKey", EmitDefaultValue = true)]
        public string CaseDefinitionKey { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a case definition with the given name.
        /// </summary>
        /// <value>Restrict to tasks that belong to a case definition with the given name.</value>
        [DataMember(Name = "caseDefinitionName", EmitDefaultValue = true)]
        public string CaseDefinitionName { get; set; }

        /// <summary>
        /// Restrict to tasks that have a case definition name that has the parameter value as a  substring.
        /// </summary>
        /// <value>Restrict to tasks that have a case definition name that has the parameter value as a  substring.</value>
        [DataMember(Name = "caseDefinitionNameLike", EmitDefaultValue = true)]
        public string CaseDefinitionNameLike { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a case execution with the given id.
        /// </summary>
        /// <value>Restrict to tasks that belong to a case execution with the given id.</value>
        [DataMember(Name = "caseExecutionId", EmitDefaultValue = true)]
        public string CaseExecutionId { get; set; }

        /// <summary>
        /// Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
        /// </summary>
        /// <value>Only include tasks which belong to one of the passed and comma-separated activity  instance ids.</value>
        [DataMember(Name = "activityInstanceIdIn", EmitDefaultValue = true)]
        public List<string> ActivityInstanceIdIn { get; set; }

        /// <summary>
        /// Only include tasks which belong to one of the passed and comma-separated  tenant ids.
        /// </summary>
        /// <value>Only include tasks which belong to one of the passed and comma-separated  tenant ids.</value>
        [DataMember(Name = "tenantIdIn", EmitDefaultValue = true)]
        public List<string> TenantIdIn { get; set; }

        /// <summary>
        /// Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutTenantId", EmitDefaultValue = true)]
        public bool? WithoutTenantId { get; set; }

        /// <summary>
        /// Restrict to tasks that the given user is assigned to.
        /// </summary>
        /// <value>Restrict to tasks that the given user is assigned to.</value>
        [DataMember(Name = "assignee", EmitDefaultValue = true)]
        public string Assignee { get; set; }

        /// <summary>
        /// Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
        /// </summary>
        /// <value>Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.</value>
        [DataMember(Name = "assigneeExpression", EmitDefaultValue = true)]
        public string AssigneeExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that have an assignee that has the parameter  value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that have an assignee that has the parameter  value as a substring.</value>
        [DataMember(Name = "assigneeLike", EmitDefaultValue = true)]
        public string AssigneeLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
        /// </summary>
        /// <value>Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.</value>
        [DataMember(Name = "assigneeLikeExpression", EmitDefaultValue = true)]
        public string AssigneeLikeExpression { get; set; }

        /// <summary>
        /// Only include tasks which are assigned to one of the passed and comma-separated user ids.
        /// </summary>
        /// <value>Only include tasks which are assigned to one of the passed and comma-separated user ids.</value>
        [DataMember(Name = "assigneeIn", EmitDefaultValue = true)]
        public List<string> AssigneeIn { get; set; }

        /// <summary>
        /// Restrict to tasks that the given user owns.
        /// </summary>
        /// <value>Restrict to tasks that the given user owns.</value>
        [DataMember(Name = "owner", EmitDefaultValue = true)]
        public string Owner { get; set; }

        /// <summary>
        /// Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
        /// </summary>
        /// <value>Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.</value>
        [DataMember(Name = "ownerExpression", EmitDefaultValue = true)]
        public string OwnerExpression { get; set; }

        /// <summary>
        /// Only include tasks that are offered to the given group.
        /// </summary>
        /// <value>Only include tasks that are offered to the given group.</value>
        [DataMember(Name = "candidateGroup", EmitDefaultValue = true)]
        public string CandidateGroup { get; set; }

        /// <summary>
        /// Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
        /// </summary>
        /// <value>Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.</value>
        [DataMember(Name = "candidateGroupExpression", EmitDefaultValue = true)]
        public string CandidateGroupExpression { get; set; }

        /// <summary>
        /// Only include tasks that are offered to the given user or to one of his groups.
        /// </summary>
        /// <value>Only include tasks that are offered to the given user or to one of his groups.</value>
        [DataMember(Name = "candidateUser", EmitDefaultValue = true)]
        public string CandidateUser { get; set; }

        /// <summary>
        /// Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
        /// </summary>
        /// <value>Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.</value>
        [DataMember(Name = "candidateUserExpression", EmitDefaultValue = true)]
        public string CandidateUserExpression { get; set; }

        /// <summary>
        /// Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
        /// </summary>
        /// <value>Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).</value>
        [DataMember(Name = "includeAssignedTasks", EmitDefaultValue = true)]
        public bool? IncludeAssignedTasks { get; set; }

        /// <summary>
        /// Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
        /// </summary>
        /// <value>Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).</value>
        [DataMember(Name = "involvedUser", EmitDefaultValue = true)]
        public string InvolvedUser { get; set; }

        /// <summary>
        /// Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
        /// </summary>
        /// <value>Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.</value>
        [DataMember(Name = "involvedUserExpression", EmitDefaultValue = true)]
        public string InvolvedUserExpression { get; set; }

        /// <summary>
        /// If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
        /// </summary>
        /// <value>If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.</value>
        [DataMember(Name = "assigned", EmitDefaultValue = true)]
        public bool? Assigned { get; set; }

        /// <summary>
        /// If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
        /// </summary>
        /// <value>If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.</value>
        [DataMember(Name = "unassigned", EmitDefaultValue = true)]
        public bool? Unassigned { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given key.
        /// </summary>
        /// <value>Restrict to tasks that have the given key.</value>
        [DataMember(Name = "taskDefinitionKey", EmitDefaultValue = true)]
        public string TaskDefinitionKey { get; set; }

        /// <summary>
        /// Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
        /// </summary>
        /// <value>Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.</value>
        [DataMember(Name = "taskDefinitionKeyIn", EmitDefaultValue = true)]
        public List<string> TaskDefinitionKeyIn { get; set; }

        /// <summary>
        /// Restrict to tasks that have a key that has the parameter value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that have a key that has the parameter value as a substring.</value>
        [DataMember(Name = "taskDefinitionKeyLike", EmitDefaultValue = true)]
        public string TaskDefinitionKeyLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given name.
        /// </summary>
        /// <value>Restrict to tasks that have the given name.</value>
        [DataMember(Name = "name", EmitDefaultValue = true)]
        public string Name { get; set; }

        /// <summary>
        /// Restrict to tasks that do not have the given name.
        /// </summary>
        /// <value>Restrict to tasks that do not have the given name.</value>
        [DataMember(Name = "nameNotEqual", EmitDefaultValue = true)]
        public string NameNotEqual { get; set; }

        /// <summary>
        /// Restrict to tasks that have a name with the given parameter value as substring.
        /// </summary>
        /// <value>Restrict to tasks that have a name with the given parameter value as substring.</value>
        [DataMember(Name = "nameLike", EmitDefaultValue = true)]
        public string NameLike { get; set; }

        /// <summary>
        /// Restrict to tasks that do not have a name with the given parameter value as substring.
        /// </summary>
        /// <value>Restrict to tasks that do not have a name with the given parameter value as substring.</value>
        [DataMember(Name = "nameNotLike", EmitDefaultValue = true)]
        public string NameNotLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given description.
        /// </summary>
        /// <value>Restrict to tasks that have the given description.</value>
        [DataMember(Name = "description", EmitDefaultValue = true)]
        public string Description { get; set; }

        /// <summary>
        /// Restrict to tasks that have a description that has the parameter value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that have a description that has the parameter value as a substring.</value>
        [DataMember(Name = "descriptionLike", EmitDefaultValue = true)]
        public string DescriptionLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given priority.
        /// </summary>
        /// <value>Restrict to tasks that have the given priority.</value>
        [DataMember(Name = "priority", EmitDefaultValue = true)]
        public int? Priority { get; set; }

        /// <summary>
        /// Restrict to tasks that have a lower or equal priority.
        /// </summary>
        /// <value>Restrict to tasks that have a lower or equal priority.</value>
        [DataMember(Name = "maxPriority", EmitDefaultValue = true)]
        public int? MaxPriority { get; set; }

        /// <summary>
        /// Restrict to tasks that have a higher or equal priority.
        /// </summary>
        /// <value>Restrict to tasks that have a higher or equal priority.</value>
        [DataMember(Name = "minPriority", EmitDefaultValue = true)]
        public int? MinPriority { get; set; }

        /// <summary>
        /// Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.</value>
        [DataMember(Name = "dueDate", EmitDefaultValue = true)]
        public DateTimeOffset? DueDate { get; set; }

        /// <summary>
        /// Restrict to tasks that are due on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that are due on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "dueDateExpression", EmitDefaultValue = true)]
        public string DueDateExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.</value>
        [DataMember(Name = "dueAfter", EmitDefaultValue = true)]
        public DateTimeOffset? DueAfter { get; set; }

        /// <summary>
        /// Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "dueAfterExpression", EmitDefaultValue = true)]
        public string DueAfterExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.</value>
        [DataMember(Name = "dueBefore", EmitDefaultValue = true)]
        public DateTimeOffset? DueBefore { get; set; }

        /// <summary>
        /// Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "dueBeforeExpression", EmitDefaultValue = true)]
        public string DueBeforeExpression { get; set; }

        /// <summary>
        /// Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutDueDate", EmitDefaultValue = true)]
        public bool? WithoutDueDate { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.</value>
        [DataMember(Name = "followUpDate", EmitDefaultValue = true)]
        public DateTimeOffset? FollowUpDate { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "followUpDateExpression", EmitDefaultValue = true)]
        public string FollowUpDateExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.</value>
        [DataMember(Name = "followUpAfter", EmitDefaultValue = true)]
        public DateTimeOffset? FollowUpAfter { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "followUpAfterExpression", EmitDefaultValue = true)]
        public string FollowUpAfterExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.</value>
        [DataMember(Name = "followUpBefore", EmitDefaultValue = true)]
        public string FollowUpBefore { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "followUpBeforeExpression", EmitDefaultValue = true)]
        public string FollowUpBeforeExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
        /// </summary>
        /// <value>Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.</value>
        [DataMember(Name = "followUpBeforeOrNotExistent", EmitDefaultValue = true)]
        public DateTimeOffset? FollowUpBeforeOrNotExistent { get; set; }

        /// <summary>
        /// Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "followUpBeforeOrNotExistentExpression", EmitDefaultValue = true)]
        public string FollowUpBeforeOrNotExistentExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.</value>
        [DataMember(Name = "createdOn", EmitDefaultValue = true)]
        public DateTimeOffset? CreatedOn { get; set; }

        /// <summary>
        /// Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "createdOnExpression", EmitDefaultValue = true)]
        public string CreatedOnExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.</value>
        [DataMember(Name = "createdAfter", EmitDefaultValue = true)]
        public DateTimeOffset? CreatedAfter { get; set; }

        /// <summary>
        /// Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "createdAfterExpression", EmitDefaultValue = true)]
        public string CreatedAfterExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.</value>
        [DataMember(Name = "createdBefore", EmitDefaultValue = true)]
        public DateTimeOffset? CreatedBefore { get; set; }

        /// <summary>
        /// Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
        /// </summary>
        /// <value>Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.</value>
        [DataMember(Name = "createdBeforeExpression", EmitDefaultValue = true)]
        public string CreatedBeforeExpression { get; set; }

        /// <summary>
        /// Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.</value>
        [DataMember(Name = "candidateGroups", EmitDefaultValue = true)]
        public List<string> CandidateGroups { get; set; }

        /// <summary>
        /// Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
        /// </summary>
        /// <value>Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.</value>
        [DataMember(Name = "candidateGroupsExpression", EmitDefaultValue = true)]
        public string CandidateGroupsExpression { get; set; }

        /// <summary>
        /// Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withCandidateGroups", EmitDefaultValue = true)]
        public bool? WithCandidateGroups { get; set; }

        /// <summary>
        /// Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutCandidateGroups", EmitDefaultValue = true)]
        public bool? WithoutCandidateGroups { get; set; }

        /// <summary>
        /// Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withCandidateUsers", EmitDefaultValue = true)]
        public bool? WithCandidateUsers { get; set; }

        /// <summary>
        /// Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutCandidateUsers", EmitDefaultValue = true)]
        public bool? WithoutCandidateUsers { get; set; }

        /// <summary>
        /// Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "active", EmitDefaultValue = true)]
        public bool? Active { get; set; }

        /// <summary>
        /// Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "suspended", EmitDefaultValue = true)]
        public bool? Suspended { get; set; }

        /// <summary>
        /// A JSON array to only include tasks that have variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
        /// </summary>
        /// <value>A JSON array to only include tasks that have variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.</value>
        [DataMember(Name = "taskVariables", EmitDefaultValue = true)]
        public List<VariableQueryParameterDto> TaskVariables { get; set; }

        /// <summary>
        /// A JSON array to only include tasks that belong to a process instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
        /// </summary>
        /// <value>A JSON array to only include tasks that belong to a process instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.</value>
        [DataMember(Name = "processVariables", EmitDefaultValue = true)]
        public List<VariableQueryParameterDto> ProcessVariables { get; set; }

        /// <summary>
        /// A JSON array to only include tasks that belong to a case instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
        /// </summary>
        /// <value>A JSON array to only include tasks that belong to a case instance with variables with certain values. The array consists of JSON objects with three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. &#x60;value&#x60; may be of type &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.</value>
        [DataMember(Name = "caseInstanceVariables", EmitDefaultValue = true)]
        public List<VariableQueryParameterDto> CaseInstanceVariables { get; set; }

        /// <summary>
        /// Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
        /// </summary>
        /// <value>Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.</value>
        [DataMember(Name = "variableNamesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableNamesIgnoreCase { get; set; }

        /// <summary>
        /// Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
        /// </summary>
        /// <value>Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.</value>
        [DataMember(Name = "variableValuesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableValuesIgnoreCase { get; set; }

        /// <summary>
        /// Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
        /// </summary>
        /// <value>Restrict query to all tasks that are sub tasks of the given task. Takes a task id.</value>
        [DataMember(Name = "parentTaskId", EmitDefaultValue = true)]
        public string ParentTaskId { get; set; }

        /// <summary>
        /// A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills *at least one* of the query&#39;s predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task query properties can be used except for: &#x60;sorting&#x60;, &#x60;withCandidateGroups&#x60;, &#x60;withoutCandidateGroups&#x60;, &#x60;withCandidateUsers&#x60;, &#x60;withoutCandidateUsers&#x60;  See the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
        /// </summary>
        /// <value>A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills *at least one* of the query&#39;s predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task query properties can be used except for: &#x60;sorting&#x60;, &#x60;withCandidateGroups&#x60;, &#x60;withoutCandidateGroups&#x60;, &#x60;withCandidateUsers&#x60;, &#x60;withoutCandidateUsers&#x60;  See the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.</value>
        [DataMember(Name = "orQueries", EmitDefaultValue = true)]
        public List<TaskQueryDto> OrQueries { get; set; }

        /// <summary>
        /// Apply sorting of the result
        /// </summary>
        /// <value>Apply sorting of the result</value>
        [DataMember(Name = "sorting", EmitDefaultValue = false)]
        public List<TaskQueryDtoSorting> Sorting { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TaskQueryDto {\n");
            sb.Append("  ProcessInstanceId: ").Append(ProcessInstanceId).Append("\n");
            sb.Append("  ProcessInstanceIdIn: ").Append(ProcessInstanceIdIn).Append("\n");
            sb.Append("  ProcessInstanceBusinessKey: ").Append(ProcessInstanceBusinessKey).Append("\n");
            sb.Append("  ProcessInstanceBusinessKeyExpression: ").Append(ProcessInstanceBusinessKeyExpression).Append("\n");
            sb.Append("  ProcessInstanceBusinessKeyIn: ").Append(ProcessInstanceBusinessKeyIn).Append("\n");
            sb.Append("  ProcessInstanceBusinessKeyLike: ").Append(ProcessInstanceBusinessKeyLike).Append("\n");
            sb.Append("  ProcessInstanceBusinessKeyLikeExpression: ").Append(ProcessInstanceBusinessKeyLikeExpression).Append("\n");
            sb.Append("  ProcessDefinitionId: ").Append(ProcessDefinitionId).Append("\n");
            sb.Append("  ProcessDefinitionKey: ").Append(ProcessDefinitionKey).Append("\n");
            sb.Append("  ProcessDefinitionKeyIn: ").Append(ProcessDefinitionKeyIn).Append("\n");
            sb.Append("  ProcessDefinitionName: ").Append(ProcessDefinitionName).Append("\n");
            sb.Append("  ProcessDefinitionNameLike: ").Append(ProcessDefinitionNameLike).Append("\n");
            sb.Append("  ExecutionId: ").Append(ExecutionId).Append("\n");
            sb.Append("  CaseInstanceId: ").Append(CaseInstanceId).Append("\n");
            sb.Append("  CaseInstanceBusinessKey: ").Append(CaseInstanceBusinessKey).Append("\n");
            sb.Append("  CaseInstanceBusinessKeyLike: ").Append(CaseInstanceBusinessKeyLike).Append("\n");
            sb.Append("  CaseDefinitionId: ").Append(CaseDefinitionId).Append("\n");
            sb.Append("  CaseDefinitionKey: ").Append(CaseDefinitionKey).Append("\n");
            sb.Append("  CaseDefinitionName: ").Append(CaseDefinitionName).Append("\n");
            sb.Append("  CaseDefinitionNameLike: ").Append(CaseDefinitionNameLike).Append("\n");
            sb.Append("  CaseExecutionId: ").Append(CaseExecutionId).Append("\n");
            sb.Append("  ActivityInstanceIdIn: ").Append(ActivityInstanceIdIn).Append("\n");
            sb.Append("  TenantIdIn: ").Append(TenantIdIn).Append("\n");
            sb.Append("  WithoutTenantId: ").Append(WithoutTenantId).Append("\n");
            sb.Append("  Assignee: ").Append(Assignee).Append("\n");
            sb.Append("  AssigneeExpression: ").Append(AssigneeExpression).Append("\n");
            sb.Append("  AssigneeLike: ").Append(AssigneeLike).Append("\n");
            sb.Append("  AssigneeLikeExpression: ").Append(AssigneeLikeExpression).Append("\n");
            sb.Append("  AssigneeIn: ").Append(AssigneeIn).Append("\n");
            sb.Append("  Owner: ").Append(Owner).Append("\n");
            sb.Append("  OwnerExpression: ").Append(OwnerExpression).Append("\n");
            sb.Append("  CandidateGroup: ").Append(CandidateGroup).Append("\n");
            sb.Append("  CandidateGroupExpression: ").Append(CandidateGroupExpression).Append("\n");
            sb.Append("  CandidateUser: ").Append(CandidateUser).Append("\n");
            sb.Append("  CandidateUserExpression: ").Append(CandidateUserExpression).Append("\n");
            sb.Append("  IncludeAssignedTasks: ").Append(IncludeAssignedTasks).Append("\n");
            sb.Append("  InvolvedUser: ").Append(InvolvedUser).Append("\n");
            sb.Append("  InvolvedUserExpression: ").Append(InvolvedUserExpression).Append("\n");
            sb.Append("  Assigned: ").Append(Assigned).Append("\n");
            sb.Append("  Unassigned: ").Append(Unassigned).Append("\n");
            sb.Append("  TaskDefinitionKey: ").Append(TaskDefinitionKey).Append("\n");
            sb.Append("  TaskDefinitionKeyIn: ").Append(TaskDefinitionKeyIn).Append("\n");
            sb.Append("  TaskDefinitionKeyLike: ").Append(TaskDefinitionKeyLike).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  NameNotEqual: ").Append(NameNotEqual).Append("\n");
            sb.Append("  NameLike: ").Append(NameLike).Append("\n");
            sb.Append("  NameNotLike: ").Append(NameNotLike).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  DescriptionLike: ").Append(DescriptionLike).Append("\n");
            sb.Append("  Priority: ").Append(Priority).Append("\n");
            sb.Append("  MaxPriority: ").Append(MaxPriority).Append("\n");
            sb.Append("  MinPriority: ").Append(MinPriority).Append("\n");
            sb.Append("  DueDate: ").Append(DueDate).Append("\n");
            sb.Append("  DueDateExpression: ").Append(DueDateExpression).Append("\n");
            sb.Append("  DueAfter: ").Append(DueAfter).Append("\n");
            sb.Append("  DueAfterExpression: ").Append(DueAfterExpression).Append("\n");
            sb.Append("  DueBefore: ").Append(DueBefore).Append("\n");
            sb.Append("  DueBeforeExpression: ").Append(DueBeforeExpression).Append("\n");
            sb.Append("  WithoutDueDate: ").Append(WithoutDueDate).Append("\n");
            sb.Append("  FollowUpDate: ").Append(FollowUpDate).Append("\n");
            sb.Append("  FollowUpDateExpression: ").Append(FollowUpDateExpression).Append("\n");
            sb.Append("  FollowUpAfter: ").Append(FollowUpAfter).Append("\n");
            sb.Append("  FollowUpAfterExpression: ").Append(FollowUpAfterExpression).Append("\n");
            sb.Append("  FollowUpBefore: ").Append(FollowUpBefore).Append("\n");
            sb.Append("  FollowUpBeforeExpression: ").Append(FollowUpBeforeExpression).Append("\n");
            sb.Append("  FollowUpBeforeOrNotExistent: ").Append(FollowUpBeforeOrNotExistent).Append("\n");
            sb.Append("  FollowUpBeforeOrNotExistentExpression: ").Append(FollowUpBeforeOrNotExistentExpression).Append("\n");
            sb.Append("  CreatedOn: ").Append(CreatedOn).Append("\n");
            sb.Append("  CreatedOnExpression: ").Append(CreatedOnExpression).Append("\n");
            sb.Append("  CreatedAfter: ").Append(CreatedAfter).Append("\n");
            sb.Append("  CreatedAfterExpression: ").Append(CreatedAfterExpression).Append("\n");
            sb.Append("  CreatedBefore: ").Append(CreatedBefore).Append("\n");
            sb.Append("  CreatedBeforeExpression: ").Append(CreatedBeforeExpression).Append("\n");
            sb.Append("  DelegationState: ").Append(DelegationState).Append("\n");
            sb.Append("  CandidateGroups: ").Append(CandidateGroups).Append("\n");
            sb.Append("  CandidateGroupsExpression: ").Append(CandidateGroupsExpression).Append("\n");
            sb.Append("  WithCandidateGroups: ").Append(WithCandidateGroups).Append("\n");
            sb.Append("  WithoutCandidateGroups: ").Append(WithoutCandidateGroups).Append("\n");
            sb.Append("  WithCandidateUsers: ").Append(WithCandidateUsers).Append("\n");
            sb.Append("  WithoutCandidateUsers: ").Append(WithoutCandidateUsers).Append("\n");
            sb.Append("  Active: ").Append(Active).Append("\n");
            sb.Append("  Suspended: ").Append(Suspended).Append("\n");
            sb.Append("  TaskVariables: ").Append(TaskVariables).Append("\n");
            sb.Append("  ProcessVariables: ").Append(ProcessVariables).Append("\n");
            sb.Append("  CaseInstanceVariables: ").Append(CaseInstanceVariables).Append("\n");
            sb.Append("  VariableNamesIgnoreCase: ").Append(VariableNamesIgnoreCase).Append("\n");
            sb.Append("  VariableValuesIgnoreCase: ").Append(VariableValuesIgnoreCase).Append("\n");
            sb.Append("  ParentTaskId: ").Append(ParentTaskId).Append("\n");
            sb.Append("  OrQueries: ").Append(OrQueries).Append("\n");
            sb.Append("  Sorting: ").Append(Sorting).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TaskQueryDto);
        }

        /// <summary>
        /// Returns true if TaskQueryDto instances are equal
        /// </summary>
        /// <param name="input">Instance of TaskQueryDto to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TaskQueryDto input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.ProcessInstanceId == input.ProcessInstanceId ||
                    (this.ProcessInstanceId != null &&
                    this.ProcessInstanceId.Equals(input.ProcessInstanceId))
                ) && 
                (
                    this.ProcessInstanceIdIn == input.ProcessInstanceIdIn ||
                    this.ProcessInstanceIdIn != null &&
                    input.ProcessInstanceIdIn != null &&
                    this.ProcessInstanceIdIn.SequenceEqual(input.ProcessInstanceIdIn)
                ) && 
                (
                    this.ProcessInstanceBusinessKey == input.ProcessInstanceBusinessKey ||
                    (this.ProcessInstanceBusinessKey != null &&
                    this.ProcessInstanceBusinessKey.Equals(input.ProcessInstanceBusinessKey))
                ) && 
                (
                    this.ProcessInstanceBusinessKeyExpression == input.ProcessInstanceBusinessKeyExpression ||
                    (this.ProcessInstanceBusinessKeyExpression != null &&
                    this.ProcessInstanceBusinessKeyExpression.Equals(input.ProcessInstanceBusinessKeyExpression))
                ) && 
                (
                    this.ProcessInstanceBusinessKeyIn == input.ProcessInstanceBusinessKeyIn ||
                    this.ProcessInstanceBusinessKeyIn != null &&
                    input.ProcessInstanceBusinessKeyIn != null &&
                    this.ProcessInstanceBusinessKeyIn.SequenceEqual(input.ProcessInstanceBusinessKeyIn)
                ) && 
                (
                    this.ProcessInstanceBusinessKeyLike == input.ProcessInstanceBusinessKeyLike ||
                    (this.ProcessInstanceBusinessKeyLike != null &&
                    this.ProcessInstanceBusinessKeyLike.Equals(input.ProcessInstanceBusinessKeyLike))
                ) && 
                (
                    this.ProcessInstanceBusinessKeyLikeExpression == input.ProcessInstanceBusinessKeyLikeExpression ||
                    (this.ProcessInstanceBusinessKeyLikeExpression != null &&
                    this.ProcessInstanceBusinessKeyLikeExpression.Equals(input.ProcessInstanceBusinessKeyLikeExpression))
                ) && 
                (
                    this.ProcessDefinitionId == input.ProcessDefinitionId ||
                    (this.ProcessDefinitionId != null &&
                    this.ProcessDefinitionId.Equals(input.ProcessDefinitionId))
                ) && 
                (
                    this.ProcessDefinitionKey == input.ProcessDefinitionKey ||
                    (this.ProcessDefinitionKey != null &&
                    this.ProcessDefinitionKey.Equals(input.ProcessDefinitionKey))
                ) && 
                (
                    this.ProcessDefinitionKeyIn == input.ProcessDefinitionKeyIn ||
                    this.ProcessDefinitionKeyIn != null &&
                    input.ProcessDefinitionKeyIn != null &&
                    this.ProcessDefinitionKeyIn.SequenceEqual(input.ProcessDefinitionKeyIn)
                ) && 
                (
                    this.ProcessDefinitionName == input.ProcessDefinitionName ||
                    (this.ProcessDefinitionName != null &&
                    this.ProcessDefinitionName.Equals(input.ProcessDefinitionName))
                ) && 
                (
                    this.ProcessDefinitionNameLike == input.ProcessDefinitionNameLike ||
                    (this.ProcessDefinitionNameLike != null &&
                    this.ProcessDefinitionNameLike.Equals(input.ProcessDefinitionNameLike))
                ) && 
                (
                    this.ExecutionId == input.ExecutionId ||
                    (this.ExecutionId != null &&
                    this.ExecutionId.Equals(input.ExecutionId))
                ) && 
                (
                    this.CaseInstanceId == input.CaseInstanceId ||
                    (this.CaseInstanceId != null &&
                    this.CaseInstanceId.Equals(input.CaseInstanceId))
                ) && 
                (
                    this.CaseInstanceBusinessKey == input.CaseInstanceBusinessKey ||
                    (this.CaseInstanceBusinessKey != null &&
                    this.CaseInstanceBusinessKey.Equals(input.CaseInstanceBusinessKey))
                ) && 
                (
                    this.CaseInstanceBusinessKeyLike == input.CaseInstanceBusinessKeyLike ||
                    (this.CaseInstanceBusinessKeyLike != null &&
                    this.CaseInstanceBusinessKeyLike.Equals(input.CaseInstanceBusinessKeyLike))
                ) && 
                (
                    this.CaseDefinitionId == input.CaseDefinitionId ||
                    (this.CaseDefinitionId != null &&
                    this.CaseDefinitionId.Equals(input.CaseDefinitionId))
                ) && 
                (
                    this.CaseDefinitionKey == input.CaseDefinitionKey ||
                    (this.CaseDefinitionKey != null &&
                    this.CaseDefinitionKey.Equals(input.CaseDefinitionKey))
                ) && 
                (
                    this.CaseDefinitionName == input.CaseDefinitionName ||
                    (this.CaseDefinitionName != null &&
                    this.CaseDefinitionName.Equals(input.CaseDefinitionName))
                ) && 
                (
                    this.CaseDefinitionNameLike == input.CaseDefinitionNameLike ||
                    (this.CaseDefinitionNameLike != null &&
                    this.CaseDefinitionNameLike.Equals(input.CaseDefinitionNameLike))
                ) && 
                (
                    this.CaseExecutionId == input.CaseExecutionId ||
                    (this.CaseExecutionId != null &&
                    this.CaseExecutionId.Equals(input.CaseExecutionId))
                ) && 
                (
                    this.ActivityInstanceIdIn == input.ActivityInstanceIdIn ||
                    this.ActivityInstanceIdIn != null &&
                    input.ActivityInstanceIdIn != null &&
                    this.ActivityInstanceIdIn.SequenceEqual(input.ActivityInstanceIdIn)
                ) && 
                (
                    this.TenantIdIn == input.TenantIdIn ||
                    this.TenantIdIn != null &&
                    input.TenantIdIn != null &&
                    this.TenantIdIn.SequenceEqual(input.TenantIdIn)
                ) && 
                (
                    this.WithoutTenantId == input.WithoutTenantId ||
                    (this.WithoutTenantId != null &&
                    this.WithoutTenantId.Equals(input.WithoutTenantId))
                ) && 
                (
                    this.Assignee == input.Assignee ||
                    (this.Assignee != null &&
                    this.Assignee.Equals(input.Assignee))
                ) && 
                (
                    this.AssigneeExpression == input.AssigneeExpression ||
                    (this.AssigneeExpression != null &&
                    this.AssigneeExpression.Equals(input.AssigneeExpression))
                ) && 
                (
                    this.AssigneeLike == input.AssigneeLike ||
                    (this.AssigneeLike != null &&
                    this.AssigneeLike.Equals(input.AssigneeLike))
                ) && 
                (
                    this.AssigneeLikeExpression == input.AssigneeLikeExpression ||
                    (this.AssigneeLikeExpression != null &&
                    this.AssigneeLikeExpression.Equals(input.AssigneeLikeExpression))
                ) && 
                (
                    this.AssigneeIn == input.AssigneeIn ||
                    this.AssigneeIn != null &&
                    input.AssigneeIn != null &&
                    this.AssigneeIn.SequenceEqual(input.AssigneeIn)
                ) && 
                (
                    this.Owner == input.Owner ||
                    (this.Owner != null &&
                    this.Owner.Equals(input.Owner))
                ) && 
                (
                    this.OwnerExpression == input.OwnerExpression ||
                    (this.OwnerExpression != null &&
                    this.OwnerExpression.Equals(input.OwnerExpression))
                ) && 
                (
                    this.CandidateGroup == input.CandidateGroup ||
                    (this.CandidateGroup != null &&
                    this.CandidateGroup.Equals(input.CandidateGroup))
                ) && 
                (
                    this.CandidateGroupExpression == input.CandidateGroupExpression ||
                    (this.CandidateGroupExpression != null &&
                    this.CandidateGroupExpression.Equals(input.CandidateGroupExpression))
                ) && 
                (
                    this.CandidateUser == input.CandidateUser ||
                    (this.CandidateUser != null &&
                    this.CandidateUser.Equals(input.CandidateUser))
                ) && 
                (
                    this.CandidateUserExpression == input.CandidateUserExpression ||
                    (this.CandidateUserExpression != null &&
                    this.CandidateUserExpression.Equals(input.CandidateUserExpression))
                ) && 
                (
                    this.IncludeAssignedTasks == input.IncludeAssignedTasks ||
                    (this.IncludeAssignedTasks != null &&
                    this.IncludeAssignedTasks.Equals(input.IncludeAssignedTasks))
                ) && 
                (
                    this.InvolvedUser == input.InvolvedUser ||
                    (this.InvolvedUser != null &&
                    this.InvolvedUser.Equals(input.InvolvedUser))
                ) && 
                (
                    this.InvolvedUserExpression == input.InvolvedUserExpression ||
                    (this.InvolvedUserExpression != null &&
                    this.InvolvedUserExpression.Equals(input.InvolvedUserExpression))
                ) && 
                (
                    this.Assigned == input.Assigned ||
                    (this.Assigned != null &&
                    this.Assigned.Equals(input.Assigned))
                ) && 
                (
                    this.Unassigned == input.Unassigned ||
                    (this.Unassigned != null &&
                    this.Unassigned.Equals(input.Unassigned))
                ) && 
                (
                    this.TaskDefinitionKey == input.TaskDefinitionKey ||
                    (this.TaskDefinitionKey != null &&
                    this.TaskDefinitionKey.Equals(input.TaskDefinitionKey))
                ) && 
                (
                    this.TaskDefinitionKeyIn == input.TaskDefinitionKeyIn ||
                    this.TaskDefinitionKeyIn != null &&
                    input.TaskDefinitionKeyIn != null &&
                    this.TaskDefinitionKeyIn.SequenceEqual(input.TaskDefinitionKeyIn)
                ) && 
                (
                    this.TaskDefinitionKeyLike == input.TaskDefinitionKeyLike ||
                    (this.TaskDefinitionKeyLike != null &&
                    this.TaskDefinitionKeyLike.Equals(input.TaskDefinitionKeyLike))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.NameNotEqual == input.NameNotEqual ||
                    (this.NameNotEqual != null &&
                    this.NameNotEqual.Equals(input.NameNotEqual))
                ) && 
                (
                    this.NameLike == input.NameLike ||
                    (this.NameLike != null &&
                    this.NameLike.Equals(input.NameLike))
                ) && 
                (
                    this.NameNotLike == input.NameNotLike ||
                    (this.NameNotLike != null &&
                    this.NameNotLike.Equals(input.NameNotLike))
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.DescriptionLike == input.DescriptionLike ||
                    (this.DescriptionLike != null &&
                    this.DescriptionLike.Equals(input.DescriptionLike))
                ) && 
                (
                    this.Priority == input.Priority ||
                    (this.Priority != null &&
                    this.Priority.Equals(input.Priority))
                ) && 
                (
                    this.MaxPriority == input.MaxPriority ||
                    (this.MaxPriority != null &&
                    this.MaxPriority.Equals(input.MaxPriority))
                ) && 
                (
                    this.MinPriority == input.MinPriority ||
                    (this.MinPriority != null &&
                    this.MinPriority.Equals(input.MinPriority))
                ) && 
                (
                    this.DueDate == input.DueDate ||
                    (this.DueDate != null &&
                    this.DueDate.Equals(input.DueDate))
                ) && 
                (
                    this.DueDateExpression == input.DueDateExpression ||
                    (this.DueDateExpression != null &&
                    this.DueDateExpression.Equals(input.DueDateExpression))
                ) && 
                (
                    this.DueAfter == input.DueAfter ||
                    (this.DueAfter != null &&
                    this.DueAfter.Equals(input.DueAfter))
                ) && 
                (
                    this.DueAfterExpression == input.DueAfterExpression ||
                    (this.DueAfterExpression != null &&
                    this.DueAfterExpression.Equals(input.DueAfterExpression))
                ) && 
                (
                    this.DueBefore == input.DueBefore ||
                    (this.DueBefore != null &&
                    this.DueBefore.Equals(input.DueBefore))
                ) && 
                (
                    this.DueBeforeExpression == input.DueBeforeExpression ||
                    (this.DueBeforeExpression != null &&
                    this.DueBeforeExpression.Equals(input.DueBeforeExpression))
                ) && 
                (
                    this.WithoutDueDate == input.WithoutDueDate ||
                    (this.WithoutDueDate != null &&
                    this.WithoutDueDate.Equals(input.WithoutDueDate))
                ) && 
                (
                    this.FollowUpDate == input.FollowUpDate ||
                    (this.FollowUpDate != null &&
                    this.FollowUpDate.Equals(input.FollowUpDate))
                ) && 
                (
                    this.FollowUpDateExpression == input.FollowUpDateExpression ||
                    (this.FollowUpDateExpression != null &&
                    this.FollowUpDateExpression.Equals(input.FollowUpDateExpression))
                ) && 
                (
                    this.FollowUpAfter == input.FollowUpAfter ||
                    (this.FollowUpAfter != null &&
                    this.FollowUpAfter.Equals(input.FollowUpAfter))
                ) && 
                (
                    this.FollowUpAfterExpression == input.FollowUpAfterExpression ||
                    (this.FollowUpAfterExpression != null &&
                    this.FollowUpAfterExpression.Equals(input.FollowUpAfterExpression))
                ) && 
                (
                    this.FollowUpBefore == input.FollowUpBefore ||
                    (this.FollowUpBefore != null &&
                    this.FollowUpBefore.Equals(input.FollowUpBefore))
                ) && 
                (
                    this.FollowUpBeforeExpression == input.FollowUpBeforeExpression ||
                    (this.FollowUpBeforeExpression != null &&
                    this.FollowUpBeforeExpression.Equals(input.FollowUpBeforeExpression))
                ) && 
                (
                    this.FollowUpBeforeOrNotExistent == input.FollowUpBeforeOrNotExistent ||
                    (this.FollowUpBeforeOrNotExistent != null &&
                    this.FollowUpBeforeOrNotExistent.Equals(input.FollowUpBeforeOrNotExistent))
                ) && 
                (
                    this.FollowUpBeforeOrNotExistentExpression == input.FollowUpBeforeOrNotExistentExpression ||
                    (this.FollowUpBeforeOrNotExistentExpression != null &&
                    this.FollowUpBeforeOrNotExistentExpression.Equals(input.FollowUpBeforeOrNotExistentExpression))
                ) && 
                (
                    this.CreatedOn == input.CreatedOn ||
                    (this.CreatedOn != null &&
                    this.CreatedOn.Equals(input.CreatedOn))
                ) && 
                (
                    this.CreatedOnExpression == input.CreatedOnExpression ||
                    (this.CreatedOnExpression != null &&
                    this.CreatedOnExpression.Equals(input.CreatedOnExpression))
                ) && 
                (
                    this.CreatedAfter == input.CreatedAfter ||
                    (this.CreatedAfter != null &&
                    this.CreatedAfter.Equals(input.CreatedAfter))
                ) && 
                (
                    this.CreatedAfterExpression == input.CreatedAfterExpression ||
                    (this.CreatedAfterExpression != null &&
                    this.CreatedAfterExpression.Equals(input.CreatedAfterExpression))
                ) && 
                (
                    this.CreatedBefore == input.CreatedBefore ||
                    (this.CreatedBefore != null &&
                    this.CreatedBefore.Equals(input.CreatedBefore))
                ) && 
                (
                    this.CreatedBeforeExpression == input.CreatedBeforeExpression ||
                    (this.CreatedBeforeExpression != null &&
                    this.CreatedBeforeExpression.Equals(input.CreatedBeforeExpression))
                ) && 
                (
                    this.DelegationState == input.DelegationState ||
                    this.DelegationState.Equals(input.DelegationState)
                ) && 
                (
                    this.CandidateGroups == input.CandidateGroups ||
                    this.CandidateGroups != null &&
                    input.CandidateGroups != null &&
                    this.CandidateGroups.SequenceEqual(input.CandidateGroups)
                ) && 
                (
                    this.CandidateGroupsExpression == input.CandidateGroupsExpression ||
                    (this.CandidateGroupsExpression != null &&
                    this.CandidateGroupsExpression.Equals(input.CandidateGroupsExpression))
                ) && 
                (
                    this.WithCandidateGroups == input.WithCandidateGroups ||
                    (this.WithCandidateGroups != null &&
                    this.WithCandidateGroups.Equals(input.WithCandidateGroups))
                ) && 
                (
                    this.WithoutCandidateGroups == input.WithoutCandidateGroups ||
                    (this.WithoutCandidateGroups != null &&
                    this.WithoutCandidateGroups.Equals(input.WithoutCandidateGroups))
                ) && 
                (
                    this.WithCandidateUsers == input.WithCandidateUsers ||
                    (this.WithCandidateUsers != null &&
                    this.WithCandidateUsers.Equals(input.WithCandidateUsers))
                ) && 
                (
                    this.WithoutCandidateUsers == input.WithoutCandidateUsers ||
                    (this.WithoutCandidateUsers != null &&
                    this.WithoutCandidateUsers.Equals(input.WithoutCandidateUsers))
                ) && 
                (
                    this.Active == input.Active ||
                    (this.Active != null &&
                    this.Active.Equals(input.Active))
                ) && 
                (
                    this.Suspended == input.Suspended ||
                    (this.Suspended != null &&
                    this.Suspended.Equals(input.Suspended))
                ) && 
                (
                    this.TaskVariables == input.TaskVariables ||
                    this.TaskVariables != null &&
                    input.TaskVariables != null &&
                    this.TaskVariables.SequenceEqual(input.TaskVariables)
                ) && 
                (
                    this.ProcessVariables == input.ProcessVariables ||
                    this.ProcessVariables != null &&
                    input.ProcessVariables != null &&
                    this.ProcessVariables.SequenceEqual(input.ProcessVariables)
                ) && 
                (
                    this.CaseInstanceVariables == input.CaseInstanceVariables ||
                    this.CaseInstanceVariables != null &&
                    input.CaseInstanceVariables != null &&
                    this.CaseInstanceVariables.SequenceEqual(input.CaseInstanceVariables)
                ) && 
                (
                    this.VariableNamesIgnoreCase == input.VariableNamesIgnoreCase ||
                    (this.VariableNamesIgnoreCase != null &&
                    this.VariableNamesIgnoreCase.Equals(input.VariableNamesIgnoreCase))
                ) && 
                (
                    this.VariableValuesIgnoreCase == input.VariableValuesIgnoreCase ||
                    (this.VariableValuesIgnoreCase != null &&
                    this.VariableValuesIgnoreCase.Equals(input.VariableValuesIgnoreCase))
                ) && 
                (
                    this.ParentTaskId == input.ParentTaskId ||
                    (this.ParentTaskId != null &&
                    this.ParentTaskId.Equals(input.ParentTaskId))
                ) && 
                (
                    this.OrQueries == input.OrQueries ||
                    this.OrQueries != null &&
                    input.OrQueries != null &&
                    this.OrQueries.SequenceEqual(input.OrQueries)
                ) && 
                (
                    this.Sorting == input.Sorting ||
                    this.Sorting != null &&
                    input.Sorting != null &&
                    this.Sorting.SequenceEqual(input.Sorting)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ProcessInstanceId != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceId.GetHashCode();
                if (this.ProcessInstanceIdIn != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceIdIn.GetHashCode();
                if (this.ProcessInstanceBusinessKey != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceBusinessKey.GetHashCode();
                if (this.ProcessInstanceBusinessKeyExpression != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceBusinessKeyExpression.GetHashCode();
                if (this.ProcessInstanceBusinessKeyIn != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceBusinessKeyIn.GetHashCode();
                if (this.ProcessInstanceBusinessKeyLike != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceBusinessKeyLike.GetHashCode();
                if (this.ProcessInstanceBusinessKeyLikeExpression != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceBusinessKeyLikeExpression.GetHashCode();
                if (this.ProcessDefinitionId != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionId.GetHashCode();
                if (this.ProcessDefinitionKey != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionKey.GetHashCode();
                if (this.ProcessDefinitionKeyIn != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionKeyIn.GetHashCode();
                if (this.ProcessDefinitionName != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionName.GetHashCode();
                if (this.ProcessDefinitionNameLike != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionNameLike.GetHashCode();
                if (this.ExecutionId != null)
                    hashCode = hashCode * 59 + this.ExecutionId.GetHashCode();
                if (this.CaseInstanceId != null)
                    hashCode = hashCode * 59 + this.CaseInstanceId.GetHashCode();
                if (this.CaseInstanceBusinessKey != null)
                    hashCode = hashCode * 59 + this.CaseInstanceBusinessKey.GetHashCode();
                if (this.CaseInstanceBusinessKeyLike != null)
                    hashCode = hashCode * 59 + this.CaseInstanceBusinessKeyLike.GetHashCode();
                if (this.CaseDefinitionId != null)
                    hashCode = hashCode * 59 + this.CaseDefinitionId.GetHashCode();
                if (this.CaseDefinitionKey != null)
                    hashCode = hashCode * 59 + this.CaseDefinitionKey.GetHashCode();
                if (this.CaseDefinitionName != null)
                    hashCode = hashCode * 59 + this.CaseDefinitionName.GetHashCode();
                if (this.CaseDefinitionNameLike != null)
                    hashCode = hashCode * 59 + this.CaseDefinitionNameLike.GetHashCode();
                if (this.CaseExecutionId != null)
                    hashCode = hashCode * 59 + this.CaseExecutionId.GetHashCode();
                if (this.ActivityInstanceIdIn != null)
                    hashCode = hashCode * 59 + this.ActivityInstanceIdIn.GetHashCode();
                if (this.TenantIdIn != null)
                    hashCode = hashCode * 59 + this.TenantIdIn.GetHashCode();
                if (this.WithoutTenantId != null)
                    hashCode = hashCode * 59 + this.WithoutTenantId.GetHashCode();
                if (this.Assignee != null)
                    hashCode = hashCode * 59 + this.Assignee.GetHashCode();
                if (this.AssigneeExpression != null)
                    hashCode = hashCode * 59 + this.AssigneeExpression.GetHashCode();
                if (this.AssigneeLike != null)
                    hashCode = hashCode * 59 + this.AssigneeLike.GetHashCode();
                if (this.AssigneeLikeExpression != null)
                    hashCode = hashCode * 59 + this.AssigneeLikeExpression.GetHashCode();
                if (this.AssigneeIn != null)
                    hashCode = hashCode * 59 + this.AssigneeIn.GetHashCode();
                if (this.Owner != null)
                    hashCode = hashCode * 59 + this.Owner.GetHashCode();
                if (this.OwnerExpression != null)
                    hashCode = hashCode * 59 + this.OwnerExpression.GetHashCode();
                if (this.CandidateGroup != null)
                    hashCode = hashCode * 59 + this.CandidateGroup.GetHashCode();
                if (this.CandidateGroupExpression != null)
                    hashCode = hashCode * 59 + this.CandidateGroupExpression.GetHashCode();
                if (this.CandidateUser != null)
                    hashCode = hashCode * 59 + this.CandidateUser.GetHashCode();
                if (this.CandidateUserExpression != null)
                    hashCode = hashCode * 59 + this.CandidateUserExpression.GetHashCode();
                if (this.IncludeAssignedTasks != null)
                    hashCode = hashCode * 59 + this.IncludeAssignedTasks.GetHashCode();
                if (this.InvolvedUser != null)
                    hashCode = hashCode * 59 + this.InvolvedUser.GetHashCode();
                if (this.InvolvedUserExpression != null)
                    hashCode = hashCode * 59 + this.InvolvedUserExpression.GetHashCode();
                if (this.Assigned != null)
                    hashCode = hashCode * 59 + this.Assigned.GetHashCode();
                if (this.Unassigned != null)
                    hashCode = hashCode * 59 + this.Unassigned.GetHashCode();
                if (this.TaskDefinitionKey != null)
                    hashCode = hashCode * 59 + this.TaskDefinitionKey.GetHashCode();
                if (this.TaskDefinitionKeyIn != null)
                    hashCode = hashCode * 59 + this.TaskDefinitionKeyIn.GetHashCode();
                if (this.TaskDefinitionKeyLike != null)
                    hashCode = hashCode * 59 + this.TaskDefinitionKeyLike.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.NameNotEqual != null)
                    hashCode = hashCode * 59 + this.NameNotEqual.GetHashCode();
                if (this.NameLike != null)
                    hashCode = hashCode * 59 + this.NameLike.GetHashCode();
                if (this.NameNotLike != null)
                    hashCode = hashCode * 59 + this.NameNotLike.GetHashCode();
                if (this.Description != null)
                    hashCode = hashCode * 59 + this.Description.GetHashCode();
                if (this.DescriptionLike != null)
                    hashCode = hashCode * 59 + this.DescriptionLike.GetHashCode();
                if (this.Priority != null)
                    hashCode = hashCode * 59 + this.Priority.GetHashCode();
                if (this.MaxPriority != null)
                    hashCode = hashCode * 59 + this.MaxPriority.GetHashCode();
                if (this.MinPriority != null)
                    hashCode = hashCode * 59 + this.MinPriority.GetHashCode();
                if (this.DueDate != null)
                    hashCode = hashCode * 59 + this.DueDate.GetHashCode();
                if (this.DueDateExpression != null)
                    hashCode = hashCode * 59 + this.DueDateExpression.GetHashCode();
                if (this.DueAfter != null)
                    hashCode = hashCode * 59 + this.DueAfter.GetHashCode();
                if (this.DueAfterExpression != null)
                    hashCode = hashCode * 59 + this.DueAfterExpression.GetHashCode();
                if (this.DueBefore != null)
                    hashCode = hashCode * 59 + this.DueBefore.GetHashCode();
                if (this.DueBeforeExpression != null)
                    hashCode = hashCode * 59 + this.DueBeforeExpression.GetHashCode();
                if (this.WithoutDueDate != null)
                    hashCode = hashCode * 59 + this.WithoutDueDate.GetHashCode();
                if (this.FollowUpDate != null)
                    hashCode = hashCode * 59 + this.FollowUpDate.GetHashCode();
                if (this.FollowUpDateExpression != null)
                    hashCode = hashCode * 59 + this.FollowUpDateExpression.GetHashCode();
                if (this.FollowUpAfter != null)
                    hashCode = hashCode * 59 + this.FollowUpAfter.GetHashCode();
                if (this.FollowUpAfterExpression != null)
                    hashCode = hashCode * 59 + this.FollowUpAfterExpression.GetHashCode();
                if (this.FollowUpBefore != null)
                    hashCode = hashCode * 59 + this.FollowUpBefore.GetHashCode();
                if (this.FollowUpBeforeExpression != null)
                    hashCode = hashCode * 59 + this.FollowUpBeforeExpression.GetHashCode();
                if (this.FollowUpBeforeOrNotExistent != null)
                    hashCode = hashCode * 59 + this.FollowUpBeforeOrNotExistent.GetHashCode();
                if (this.FollowUpBeforeOrNotExistentExpression != null)
                    hashCode = hashCode * 59 + this.FollowUpBeforeOrNotExistentExpression.GetHashCode();
                if (this.CreatedOn != null)
                    hashCode = hashCode * 59 + this.CreatedOn.GetHashCode();
                if (this.CreatedOnExpression != null)
                    hashCode = hashCode * 59 + this.CreatedOnExpression.GetHashCode();
                if (this.CreatedAfter != null)
                    hashCode = hashCode * 59 + this.CreatedAfter.GetHashCode();
                if (this.CreatedAfterExpression != null)
                    hashCode = hashCode * 59 + this.CreatedAfterExpression.GetHashCode();
                if (this.CreatedBefore != null)
                    hashCode = hashCode * 59 + this.CreatedBefore.GetHashCode();
                if (this.CreatedBeforeExpression != null)
                    hashCode = hashCode * 59 + this.CreatedBeforeExpression.GetHashCode();
                hashCode = hashCode * 59 + this.DelegationState.GetHashCode();
                if (this.CandidateGroups != null)
                    hashCode = hashCode * 59 + this.CandidateGroups.GetHashCode();
                if (this.CandidateGroupsExpression != null)
                    hashCode = hashCode * 59 + this.CandidateGroupsExpression.GetHashCode();
                if (this.WithCandidateGroups != null)
                    hashCode = hashCode * 59 + this.WithCandidateGroups.GetHashCode();
                if (this.WithoutCandidateGroups != null)
                    hashCode = hashCode * 59 + this.WithoutCandidateGroups.GetHashCode();
                if (this.WithCandidateUsers != null)
                    hashCode = hashCode * 59 + this.WithCandidateUsers.GetHashCode();
                if (this.WithoutCandidateUsers != null)
                    hashCode = hashCode * 59 + this.WithoutCandidateUsers.GetHashCode();
                if (this.Active != null)
                    hashCode = hashCode * 59 + this.Active.GetHashCode();
                if (this.Suspended != null)
                    hashCode = hashCode * 59 + this.Suspended.GetHashCode();
                if (this.TaskVariables != null)
                    hashCode = hashCode * 59 + this.TaskVariables.GetHashCode();
                if (this.ProcessVariables != null)
                    hashCode = hashCode * 59 + this.ProcessVariables.GetHashCode();
                if (this.CaseInstanceVariables != null)
                    hashCode = hashCode * 59 + this.CaseInstanceVariables.GetHashCode();
                if (this.VariableNamesIgnoreCase != null)
                    hashCode = hashCode * 59 + this.VariableNamesIgnoreCase.GetHashCode();
                if (this.VariableValuesIgnoreCase != null)
                    hashCode = hashCode * 59 + this.VariableValuesIgnoreCase.GetHashCode();
                if (this.ParentTaskId != null)
                    hashCode = hashCode * 59 + this.ParentTaskId.GetHashCode();
                if (this.OrQueries != null)
                    hashCode = hashCode * 59 + this.OrQueries.GetHashCode();
                if (this.Sorting != null)
                    hashCode = hashCode * 59 + this.Sorting.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
