/*
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.16.0-alpha1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Camunda.Http.Api.Client.OpenAPIDateConverter;

namespace Camunda.Http.Api.Model
{
    /// <summary>
    /// A Historic Variable Instance instance query which defines a list of Historic Variable Instance instances
    /// </summary>
    [DataContract(Name = "HistoricVariableInstanceQueryDto")]
    public partial class HistoricVariableInstanceQueryDto : IEquatable<HistoricVariableInstanceQueryDto>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="HistoricVariableInstanceQueryDto" /> class.
        /// </summary>
        /// <param name="variableName">Filter by variable name..</param>
        /// <param name="variableNameLike">Restrict to variables with a name like the parameter..</param>
        /// <param name="variableValue">Filter by variable value. May be &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;..</param>
        /// <param name="variableNamesIgnoreCase">Match the variable name provided in &#x60;variableName&#x60; and &#x60;variableNameLike&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal..</param>
        /// <param name="variableValuesIgnoreCase">Match the variable value provided in &#x60;variableValue&#x60; case-insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal..</param>
        /// <param name="variableTypeIn">Only include historic variable instances which belong to one of the passed and comma- separated variable types. A list of all supported variable types can be found [here](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#supported-variable-values). **Note:** All non-primitive variables are associated with the type &#39;serializable&#39;..</param>
        /// <param name="includeDeleted">Include variables that has already been deleted during the execution..</param>
        /// <param name="processInstanceId">Filter by the process instance the variable belongs to..</param>
        /// <param name="processInstanceIdIn">Only include historic variable instances which belong to one of the passed  process instance ids..</param>
        /// <param name="processDefinitionId">Filter by the process definition the variable belongs to..</param>
        /// <param name="processDefinitionKey">Filter by a key of the process definition the variable belongs to..</param>
        /// <param name="executionIdIn">Only include historic variable instances which belong to one of the passed and  execution ids..</param>
        /// <param name="caseInstanceId">Filter by the case instance the variable belongs to..</param>
        /// <param name="caseExecutionIdIn">Only include historic variable instances which belong to one of the passed and  case execution ids..</param>
        /// <param name="caseActivityIdIn">Only include historic variable instances which belong to one of the passed and  case activity ids..</param>
        /// <param name="taskIdIn">Only include historic variable instances which belong to one of the passed and  task ids..</param>
        /// <param name="activityInstanceIdIn">Only include historic variable instances which belong to one of the passed and  activity instance ids..</param>
        /// <param name="tenantIdIn">Only include historic variable instances which belong to one of the passed and comma- separated tenant ids..</param>
        /// <param name="withoutTenantId">Only include historic variable instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="sorting">An array of criteria to sort the result by. Each element of the array is                      an object that specifies one ordering. The position in the array                      identifies the rank of an ordering, i.e., whether it is primary, secondary,                      etc. Sorting has no effect for &#x60;count&#x60; endpoints.</param>
        public HistoricVariableInstanceQueryDto(string variableName = default(string), string variableNameLike = default(string), Object variableValue = default(Object), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), List<string> variableTypeIn = default(List<string>), bool? includeDeleted = default(bool?), string processInstanceId = default(string), List<string> processInstanceIdIn = default(List<string>), string processDefinitionId = default(string), string processDefinitionKey = default(string), List<string> executionIdIn = default(List<string>), string caseInstanceId = default(string), List<string> caseExecutionIdIn = default(List<string>), List<string> caseActivityIdIn = default(List<string>), List<string> taskIdIn = default(List<string>), List<string> activityInstanceIdIn = default(List<string>), List<string> tenantIdIn = default(List<string>), bool? withoutTenantId = default(bool?), List<HistoricVariableInstanceQueryDtoSorting> sorting = default(List<HistoricVariableInstanceQueryDtoSorting>))
        {
            this.VariableName = variableName;
            this.VariableNameLike = variableNameLike;
            this.VariableValue = variableValue;
            this.VariableNamesIgnoreCase = variableNamesIgnoreCase;
            this.VariableValuesIgnoreCase = variableValuesIgnoreCase;
            this.VariableTypeIn = variableTypeIn;
            this.IncludeDeleted = includeDeleted;
            this.ProcessInstanceId = processInstanceId;
            this.ProcessInstanceIdIn = processInstanceIdIn;
            this.ProcessDefinitionId = processDefinitionId;
            this.ProcessDefinitionKey = processDefinitionKey;
            this.ExecutionIdIn = executionIdIn;
            this.CaseInstanceId = caseInstanceId;
            this.CaseExecutionIdIn = caseExecutionIdIn;
            this.CaseActivityIdIn = caseActivityIdIn;
            this.TaskIdIn = taskIdIn;
            this.ActivityInstanceIdIn = activityInstanceIdIn;
            this.TenantIdIn = tenantIdIn;
            this.WithoutTenantId = withoutTenantId;
            this.Sorting = sorting;
        }

        /// <summary>
        /// Filter by variable name.
        /// </summary>
        /// <value>Filter by variable name.</value>
        [DataMember(Name = "variableName", EmitDefaultValue = true)]
        public string VariableName { get; set; }

        /// <summary>
        /// Restrict to variables with a name like the parameter.
        /// </summary>
        /// <value>Restrict to variables with a name like the parameter.</value>
        [DataMember(Name = "variableNameLike", EmitDefaultValue = true)]
        public string VariableNameLike { get; set; }

        /// <summary>
        /// Filter by variable value. May be &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </summary>
        /// <value>Filter by variable value. May be &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.</value>
        [DataMember(Name = "variableValue", EmitDefaultValue = false)]
        public Object VariableValue { get; set; }

        /// <summary>
        /// Match the variable name provided in &#x60;variableName&#x60; and &#x60;variableNameLike&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
        /// </summary>
        /// <value>Match the variable name provided in &#x60;variableName&#x60; and &#x60;variableNameLike&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.</value>
        [DataMember(Name = "variableNamesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableNamesIgnoreCase { get; set; }

        /// <summary>
        /// Match the variable value provided in &#x60;variableValue&#x60; case-insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
        /// </summary>
        /// <value>Match the variable value provided in &#x60;variableValue&#x60; case-insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.</value>
        [DataMember(Name = "variableValuesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableValuesIgnoreCase { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed and comma- separated variable types. A list of all supported variable types can be found [here](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#supported-variable-values). **Note:** All non-primitive variables are associated with the type &#39;serializable&#39;.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed and comma- separated variable types. A list of all supported variable types can be found [here](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#supported-variable-values). **Note:** All non-primitive variables are associated with the type &#39;serializable&#39;.</value>
        [DataMember(Name = "variableTypeIn", EmitDefaultValue = true)]
        public List<string> VariableTypeIn { get; set; }

        /// <summary>
        /// Include variables that has already been deleted during the execution.
        /// </summary>
        /// <value>Include variables that has already been deleted during the execution.</value>
        [DataMember(Name = "includeDeleted", EmitDefaultValue = true)]
        public bool? IncludeDeleted { get; set; }

        /// <summary>
        /// Filter by the process instance the variable belongs to.
        /// </summary>
        /// <value>Filter by the process instance the variable belongs to.</value>
        [DataMember(Name = "processInstanceId", EmitDefaultValue = true)]
        public string ProcessInstanceId { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed  process instance ids.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed  process instance ids.</value>
        [DataMember(Name = "processInstanceIdIn", EmitDefaultValue = true)]
        public List<string> ProcessInstanceIdIn { get; set; }

        /// <summary>
        /// Filter by the process definition the variable belongs to.
        /// </summary>
        /// <value>Filter by the process definition the variable belongs to.</value>
        [DataMember(Name = "processDefinitionId", EmitDefaultValue = true)]
        public string ProcessDefinitionId { get; set; }

        /// <summary>
        /// Filter by a key of the process definition the variable belongs to.
        /// </summary>
        /// <value>Filter by a key of the process definition the variable belongs to.</value>
        [DataMember(Name = "processDefinitionKey", EmitDefaultValue = true)]
        public string ProcessDefinitionKey { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed and  execution ids.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed and  execution ids.</value>
        [DataMember(Name = "executionIdIn", EmitDefaultValue = true)]
        public List<string> ExecutionIdIn { get; set; }

        /// <summary>
        /// Filter by the case instance the variable belongs to.
        /// </summary>
        /// <value>Filter by the case instance the variable belongs to.</value>
        [DataMember(Name = "caseInstanceId", EmitDefaultValue = true)]
        public string CaseInstanceId { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed and  case execution ids.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed and  case execution ids.</value>
        [DataMember(Name = "caseExecutionIdIn", EmitDefaultValue = true)]
        public List<string> CaseExecutionIdIn { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed and  case activity ids.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed and  case activity ids.</value>
        [DataMember(Name = "caseActivityIdIn", EmitDefaultValue = true)]
        public List<string> CaseActivityIdIn { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed and  task ids.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed and  task ids.</value>
        [DataMember(Name = "taskIdIn", EmitDefaultValue = true)]
        public List<string> TaskIdIn { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed and  activity instance ids.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed and  activity instance ids.</value>
        [DataMember(Name = "activityInstanceIdIn", EmitDefaultValue = true)]
        public List<string> ActivityInstanceIdIn { get; set; }

        /// <summary>
        /// Only include historic variable instances which belong to one of the passed and comma- separated tenant ids.
        /// </summary>
        /// <value>Only include historic variable instances which belong to one of the passed and comma- separated tenant ids.</value>
        [DataMember(Name = "tenantIdIn", EmitDefaultValue = true)]
        public List<string> TenantIdIn { get; set; }

        /// <summary>
        /// Only include historic variable instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include historic variable instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutTenantId", EmitDefaultValue = true)]
        public bool? WithoutTenantId { get; set; }

        /// <summary>
        /// An array of criteria to sort the result by. Each element of the array is                      an object that specifies one ordering. The position in the array                      identifies the rank of an ordering, i.e., whether it is primary, secondary,                      etc. Sorting has no effect for &#x60;count&#x60; endpoints
        /// </summary>
        /// <value>An array of criteria to sort the result by. Each element of the array is                      an object that specifies one ordering. The position in the array                      identifies the rank of an ordering, i.e., whether it is primary, secondary,                      etc. Sorting has no effect for &#x60;count&#x60; endpoints</value>
        [DataMember(Name = "sorting", EmitDefaultValue = false)]
        public List<HistoricVariableInstanceQueryDtoSorting> Sorting { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class HistoricVariableInstanceQueryDto {\n");
            sb.Append("  VariableName: ").Append(VariableName).Append("\n");
            sb.Append("  VariableNameLike: ").Append(VariableNameLike).Append("\n");
            sb.Append("  VariableValue: ").Append(VariableValue).Append("\n");
            sb.Append("  VariableNamesIgnoreCase: ").Append(VariableNamesIgnoreCase).Append("\n");
            sb.Append("  VariableValuesIgnoreCase: ").Append(VariableValuesIgnoreCase).Append("\n");
            sb.Append("  VariableTypeIn: ").Append(VariableTypeIn).Append("\n");
            sb.Append("  IncludeDeleted: ").Append(IncludeDeleted).Append("\n");
            sb.Append("  ProcessInstanceId: ").Append(ProcessInstanceId).Append("\n");
            sb.Append("  ProcessInstanceIdIn: ").Append(ProcessInstanceIdIn).Append("\n");
            sb.Append("  ProcessDefinitionId: ").Append(ProcessDefinitionId).Append("\n");
            sb.Append("  ProcessDefinitionKey: ").Append(ProcessDefinitionKey).Append("\n");
            sb.Append("  ExecutionIdIn: ").Append(ExecutionIdIn).Append("\n");
            sb.Append("  CaseInstanceId: ").Append(CaseInstanceId).Append("\n");
            sb.Append("  CaseExecutionIdIn: ").Append(CaseExecutionIdIn).Append("\n");
            sb.Append("  CaseActivityIdIn: ").Append(CaseActivityIdIn).Append("\n");
            sb.Append("  TaskIdIn: ").Append(TaskIdIn).Append("\n");
            sb.Append("  ActivityInstanceIdIn: ").Append(ActivityInstanceIdIn).Append("\n");
            sb.Append("  TenantIdIn: ").Append(TenantIdIn).Append("\n");
            sb.Append("  WithoutTenantId: ").Append(WithoutTenantId).Append("\n");
            sb.Append("  Sorting: ").Append(Sorting).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as HistoricVariableInstanceQueryDto);
        }

        /// <summary>
        /// Returns true if HistoricVariableInstanceQueryDto instances are equal
        /// </summary>
        /// <param name="input">Instance of HistoricVariableInstanceQueryDto to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(HistoricVariableInstanceQueryDto input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.VariableName == input.VariableName ||
                    (this.VariableName != null &&
                    this.VariableName.Equals(input.VariableName))
                ) && 
                (
                    this.VariableNameLike == input.VariableNameLike ||
                    (this.VariableNameLike != null &&
                    this.VariableNameLike.Equals(input.VariableNameLike))
                ) && 
                (
                    this.VariableValue == input.VariableValue ||
                    (this.VariableValue != null &&
                    this.VariableValue.Equals(input.VariableValue))
                ) && 
                (
                    this.VariableNamesIgnoreCase == input.VariableNamesIgnoreCase ||
                    (this.VariableNamesIgnoreCase != null &&
                    this.VariableNamesIgnoreCase.Equals(input.VariableNamesIgnoreCase))
                ) && 
                (
                    this.VariableValuesIgnoreCase == input.VariableValuesIgnoreCase ||
                    (this.VariableValuesIgnoreCase != null &&
                    this.VariableValuesIgnoreCase.Equals(input.VariableValuesIgnoreCase))
                ) && 
                (
                    this.VariableTypeIn == input.VariableTypeIn ||
                    this.VariableTypeIn != null &&
                    input.VariableTypeIn != null &&
                    this.VariableTypeIn.SequenceEqual(input.VariableTypeIn)
                ) && 
                (
                    this.IncludeDeleted == input.IncludeDeleted ||
                    (this.IncludeDeleted != null &&
                    this.IncludeDeleted.Equals(input.IncludeDeleted))
                ) && 
                (
                    this.ProcessInstanceId == input.ProcessInstanceId ||
                    (this.ProcessInstanceId != null &&
                    this.ProcessInstanceId.Equals(input.ProcessInstanceId))
                ) && 
                (
                    this.ProcessInstanceIdIn == input.ProcessInstanceIdIn ||
                    this.ProcessInstanceIdIn != null &&
                    input.ProcessInstanceIdIn != null &&
                    this.ProcessInstanceIdIn.SequenceEqual(input.ProcessInstanceIdIn)
                ) && 
                (
                    this.ProcessDefinitionId == input.ProcessDefinitionId ||
                    (this.ProcessDefinitionId != null &&
                    this.ProcessDefinitionId.Equals(input.ProcessDefinitionId))
                ) && 
                (
                    this.ProcessDefinitionKey == input.ProcessDefinitionKey ||
                    (this.ProcessDefinitionKey != null &&
                    this.ProcessDefinitionKey.Equals(input.ProcessDefinitionKey))
                ) && 
                (
                    this.ExecutionIdIn == input.ExecutionIdIn ||
                    this.ExecutionIdIn != null &&
                    input.ExecutionIdIn != null &&
                    this.ExecutionIdIn.SequenceEqual(input.ExecutionIdIn)
                ) && 
                (
                    this.CaseInstanceId == input.CaseInstanceId ||
                    (this.CaseInstanceId != null &&
                    this.CaseInstanceId.Equals(input.CaseInstanceId))
                ) && 
                (
                    this.CaseExecutionIdIn == input.CaseExecutionIdIn ||
                    this.CaseExecutionIdIn != null &&
                    input.CaseExecutionIdIn != null &&
                    this.CaseExecutionIdIn.SequenceEqual(input.CaseExecutionIdIn)
                ) && 
                (
                    this.CaseActivityIdIn == input.CaseActivityIdIn ||
                    this.CaseActivityIdIn != null &&
                    input.CaseActivityIdIn != null &&
                    this.CaseActivityIdIn.SequenceEqual(input.CaseActivityIdIn)
                ) && 
                (
                    this.TaskIdIn == input.TaskIdIn ||
                    this.TaskIdIn != null &&
                    input.TaskIdIn != null &&
                    this.TaskIdIn.SequenceEqual(input.TaskIdIn)
                ) && 
                (
                    this.ActivityInstanceIdIn == input.ActivityInstanceIdIn ||
                    this.ActivityInstanceIdIn != null &&
                    input.ActivityInstanceIdIn != null &&
                    this.ActivityInstanceIdIn.SequenceEqual(input.ActivityInstanceIdIn)
                ) && 
                (
                    this.TenantIdIn == input.TenantIdIn ||
                    this.TenantIdIn != null &&
                    input.TenantIdIn != null &&
                    this.TenantIdIn.SequenceEqual(input.TenantIdIn)
                ) && 
                (
                    this.WithoutTenantId == input.WithoutTenantId ||
                    (this.WithoutTenantId != null &&
                    this.WithoutTenantId.Equals(input.WithoutTenantId))
                ) && 
                (
                    this.Sorting == input.Sorting ||
                    this.Sorting != null &&
                    input.Sorting != null &&
                    this.Sorting.SequenceEqual(input.Sorting)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.VariableName != null)
                    hashCode = hashCode * 59 + this.VariableName.GetHashCode();
                if (this.VariableNameLike != null)
                    hashCode = hashCode * 59 + this.VariableNameLike.GetHashCode();
                if (this.VariableValue != null)
                    hashCode = hashCode * 59 + this.VariableValue.GetHashCode();
                if (this.VariableNamesIgnoreCase != null)
                    hashCode = hashCode * 59 + this.VariableNamesIgnoreCase.GetHashCode();
                if (this.VariableValuesIgnoreCase != null)
                    hashCode = hashCode * 59 + this.VariableValuesIgnoreCase.GetHashCode();
                if (this.VariableTypeIn != null)
                    hashCode = hashCode * 59 + this.VariableTypeIn.GetHashCode();
                if (this.IncludeDeleted != null)
                    hashCode = hashCode * 59 + this.IncludeDeleted.GetHashCode();
                if (this.ProcessInstanceId != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceId.GetHashCode();
                if (this.ProcessInstanceIdIn != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceIdIn.GetHashCode();
                if (this.ProcessDefinitionId != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionId.GetHashCode();
                if (this.ProcessDefinitionKey != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionKey.GetHashCode();
                if (this.ExecutionIdIn != null)
                    hashCode = hashCode * 59 + this.ExecutionIdIn.GetHashCode();
                if (this.CaseInstanceId != null)
                    hashCode = hashCode * 59 + this.CaseInstanceId.GetHashCode();
                if (this.CaseExecutionIdIn != null)
                    hashCode = hashCode * 59 + this.CaseExecutionIdIn.GetHashCode();
                if (this.CaseActivityIdIn != null)
                    hashCode = hashCode * 59 + this.CaseActivityIdIn.GetHashCode();
                if (this.TaskIdIn != null)
                    hashCode = hashCode * 59 + this.TaskIdIn.GetHashCode();
                if (this.ActivityInstanceIdIn != null)
                    hashCode = hashCode * 59 + this.ActivityInstanceIdIn.GetHashCode();
                if (this.TenantIdIn != null)
                    hashCode = hashCode * 59 + this.TenantIdIn.GetHashCode();
                if (this.WithoutTenantId != null)
                    hashCode = hashCode * 59 + this.WithoutTenantId.GetHashCode();
                if (this.Sorting != null)
                    hashCode = hashCode * 59 + this.Sorting.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
