/*
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.16.0-alpha1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Camunda.Http.Api.Client.OpenAPIDateConverter;

namespace Camunda.Http.Api.Model
{
    /// <summary>
    /// A process instance query which defines a group of process instances
    /// </summary>
    [DataContract(Name = "ProcessInstanceQueryDto")]
    public partial class ProcessInstanceQueryDto : IEquatable<ProcessInstanceQueryDto>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceQueryDto" /> class.
        /// </summary>
        /// <param name="deploymentId">Filter by the deployment the id belongs to..</param>
        /// <param name="processDefinitionId">Filter by the process definition the instances run on..</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on..</param>
        /// <param name="processDefinitionKeyIn">Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of Strings..</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a list of process definition keys. A process instance must not have one of the given process definition keys. Must be a JSON array of Strings..</param>
        /// <param name="businessKey">Filter by process instance business key..</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of..</param>
        /// <param name="caseInstanceId">Filter by case instance id..</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id..</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id..</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id..</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id..</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior..</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior..</param>
        /// <param name="processInstanceIds">Filter by a list of process instance ids. Must be a JSON array of Strings..</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident..</param>
        /// <param name="incidentId">Filter by the incident id..</param>
        /// <param name="incidentType">Filter by the incident type. See the User Guide for a list of incident types..</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match..</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of..</param>
        /// <param name="tenantIdIn">Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of Strings..</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. Value may only be true, as false is the default behavior..</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id..</param>
        /// <param name="activityIdIn">Filter by a list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids..</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances..</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances).</param>
        /// <param name="variables">A JSON array to only include process instances that have variables with certain values. The array consists of objects with the three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; (String) is the variable name, &#x60;operator&#x60; (String) is the comparison operator to be used and &#x60;value&#x60; the variable value. The &#x60;value&#x60; may be String, Number or Boolean.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;..</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal..</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal..</param>
        /// <param name="orQueries">A JSON array of nested process instance queries with OR semantics. A process instance matches a nested query if it fulfills at least one of the query&#39;s predicates. With multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form). All process instance query properties can be used except for: &#x60;sorting&#x60; See the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries..</param>
        /// <param name="sorting">Apply sorting of the result.</param>
        public ProcessInstanceQueryDto(string deploymentId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), List<string> processDefinitionKeyIn = default(List<string>), List<string> processDefinitionKeyNotIn = default(List<string>), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), List<string> processInstanceIds = default(List<string>), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), List<string> tenantIdIn = default(List<string>), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), List<string> activityIdIn = default(List<string>), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), List<VariableQueryParameterDto> variables = default(List<VariableQueryParameterDto>), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), List<ProcessInstanceQueryDto> orQueries = default(List<ProcessInstanceQueryDto>), List<ProcessInstanceQueryDtoSorting> sorting = default(List<ProcessInstanceQueryDtoSorting>))
        {
            this.DeploymentId = deploymentId;
            this.ProcessDefinitionId = processDefinitionId;
            this.ProcessDefinitionKey = processDefinitionKey;
            this.ProcessDefinitionKeyIn = processDefinitionKeyIn;
            this.ProcessDefinitionKeyNotIn = processDefinitionKeyNotIn;
            this.BusinessKey = businessKey;
            this.BusinessKeyLike = businessKeyLike;
            this.CaseInstanceId = caseInstanceId;
            this.SuperProcessInstance = superProcessInstance;
            this.SubProcessInstance = subProcessInstance;
            this.SuperCaseInstance = superCaseInstance;
            this.SubCaseInstance = subCaseInstance;
            this.Active = active;
            this.Suspended = suspended;
            this.ProcessInstanceIds = processInstanceIds;
            this.WithIncident = withIncident;
            this.IncidentId = incidentId;
            this.IncidentType = incidentType;
            this.IncidentMessage = incidentMessage;
            this.IncidentMessageLike = incidentMessageLike;
            this.TenantIdIn = tenantIdIn;
            this.WithoutTenantId = withoutTenantId;
            this.ProcessDefinitionWithoutTenantId = processDefinitionWithoutTenantId;
            this.ActivityIdIn = activityIdIn;
            this.RootProcessInstances = rootProcessInstances;
            this.LeafProcessInstances = leafProcessInstances;
            this.Variables = variables;
            this.VariableNamesIgnoreCase = variableNamesIgnoreCase;
            this.VariableValuesIgnoreCase = variableValuesIgnoreCase;
            this.OrQueries = orQueries;
            this.Sorting = sorting;
        }

        /// <summary>
        /// Filter by the deployment the id belongs to.
        /// </summary>
        /// <value>Filter by the deployment the id belongs to.</value>
        [DataMember(Name = "deploymentId", EmitDefaultValue = true)]
        public string DeploymentId { get; set; }

        /// <summary>
        /// Filter by the process definition the instances run on.
        /// </summary>
        /// <value>Filter by the process definition the instances run on.</value>
        [DataMember(Name = "processDefinitionId", EmitDefaultValue = true)]
        public string ProcessDefinitionId { get; set; }

        /// <summary>
        /// Filter by the key of the process definition the instances run on.
        /// </summary>
        /// <value>Filter by the key of the process definition the instances run on.</value>
        [DataMember(Name = "processDefinitionKey", EmitDefaultValue = true)]
        public string ProcessDefinitionKey { get; set; }

        /// <summary>
        /// Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of Strings.
        /// </summary>
        /// <value>Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of Strings.</value>
        [DataMember(Name = "processDefinitionKeyIn", EmitDefaultValue = true)]
        public List<string> ProcessDefinitionKeyIn { get; set; }

        /// <summary>
        /// Exclude instances by a list of process definition keys. A process instance must not have one of the given process definition keys. Must be a JSON array of Strings.
        /// </summary>
        /// <value>Exclude instances by a list of process definition keys. A process instance must not have one of the given process definition keys. Must be a JSON array of Strings.</value>
        [DataMember(Name = "processDefinitionKeyNotIn", EmitDefaultValue = true)]
        public List<string> ProcessDefinitionKeyNotIn { get; set; }

        /// <summary>
        /// Filter by process instance business key.
        /// </summary>
        /// <value>Filter by process instance business key.</value>
        [DataMember(Name = "businessKey", EmitDefaultValue = true)]
        public string BusinessKey { get; set; }

        /// <summary>
        /// Filter by process instance business key that the parameter is a substring of.
        /// </summary>
        /// <value>Filter by process instance business key that the parameter is a substring of.</value>
        [DataMember(Name = "businessKeyLike", EmitDefaultValue = true)]
        public string BusinessKeyLike { get; set; }

        /// <summary>
        /// Filter by case instance id.
        /// </summary>
        /// <value>Filter by case instance id.</value>
        [DataMember(Name = "caseInstanceId", EmitDefaultValue = true)]
        public string CaseInstanceId { get; set; }

        /// <summary>
        /// Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
        /// </summary>
        /// <value>Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.</value>
        [DataMember(Name = "superProcessInstance", EmitDefaultValue = true)]
        public string SuperProcessInstance { get; set; }

        /// <summary>
        /// Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
        /// </summary>
        /// <value>Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.</value>
        [DataMember(Name = "subProcessInstance", EmitDefaultValue = true)]
        public string SubProcessInstance { get; set; }

        /// <summary>
        /// Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
        /// </summary>
        /// <value>Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.</value>
        [DataMember(Name = "superCaseInstance", EmitDefaultValue = true)]
        public string SuperCaseInstance { get; set; }

        /// <summary>
        /// Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
        /// </summary>
        /// <value>Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.</value>
        [DataMember(Name = "subCaseInstance", EmitDefaultValue = true)]
        public string SubCaseInstance { get; set; }

        /// <summary>
        /// Only include active process instances. Value may only be true, as false is the default behavior.
        /// </summary>
        /// <value>Only include active process instances. Value may only be true, as false is the default behavior.</value>
        [DataMember(Name = "active", EmitDefaultValue = true)]
        public bool? Active { get; set; }

        /// <summary>
        /// Only include suspended process instances. Value may only be true, as false is the default behavior.
        /// </summary>
        /// <value>Only include suspended process instances. Value may only be true, as false is the default behavior.</value>
        [DataMember(Name = "suspended", EmitDefaultValue = true)]
        public bool? Suspended { get; set; }

        /// <summary>
        /// Filter by a list of process instance ids. Must be a JSON array of Strings.
        /// </summary>
        /// <value>Filter by a list of process instance ids. Must be a JSON array of Strings.</value>
        [DataMember(Name = "processInstanceIds", EmitDefaultValue = true)]
        public List<string> ProcessInstanceIds { get; set; }

        /// <summary>
        /// Filter by presence of incidents. Selects only process instances that have an incident.
        /// </summary>
        /// <value>Filter by presence of incidents. Selects only process instances that have an incident.</value>
        [DataMember(Name = "withIncident", EmitDefaultValue = true)]
        public bool? WithIncident { get; set; }

        /// <summary>
        /// Filter by the incident id.
        /// </summary>
        /// <value>Filter by the incident id.</value>
        [DataMember(Name = "incidentId", EmitDefaultValue = true)]
        public string IncidentId { get; set; }

        /// <summary>
        /// Filter by the incident type. See the User Guide for a list of incident types.
        /// </summary>
        /// <value>Filter by the incident type. See the User Guide for a list of incident types.</value>
        [DataMember(Name = "incidentType", EmitDefaultValue = true)]
        public string IncidentType { get; set; }

        /// <summary>
        /// Filter by the incident message. Exact match.
        /// </summary>
        /// <value>Filter by the incident message. Exact match.</value>
        [DataMember(Name = "incidentMessage", EmitDefaultValue = true)]
        public string IncidentMessage { get; set; }

        /// <summary>
        /// Filter by the incident message that the parameter is a substring of.
        /// </summary>
        /// <value>Filter by the incident message that the parameter is a substring of.</value>
        [DataMember(Name = "incidentMessageLike", EmitDefaultValue = true)]
        public string IncidentMessageLike { get; set; }

        /// <summary>
        /// Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of Strings.
        /// </summary>
        /// <value>Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of Strings.</value>
        [DataMember(Name = "tenantIdIn", EmitDefaultValue = true)]
        public List<string> TenantIdIn { get; set; }

        /// <summary>
        /// Only include process instances which belong to no tenant. Value may only be true, as false is the default behavior.
        /// </summary>
        /// <value>Only include process instances which belong to no tenant. Value may only be true, as false is the default behavior.</value>
        [DataMember(Name = "withoutTenantId", EmitDefaultValue = true)]
        public bool? WithoutTenantId { get; set; }

        /// <summary>
        /// Only include process instances which process definition has no tenant id.
        /// </summary>
        /// <value>Only include process instances which process definition has no tenant id.</value>
        [DataMember(Name = "processDefinitionWithoutTenantId", EmitDefaultValue = true)]
        public bool? ProcessDefinitionWithoutTenantId { get; set; }

        /// <summary>
        /// Filter by a list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
        /// </summary>
        /// <value>Filter by a list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.</value>
        [DataMember(Name = "activityIdIn", EmitDefaultValue = true)]
        public List<string> ActivityIdIn { get; set; }

        /// <summary>
        /// Restrict the query to all process instances that are top level process instances.
        /// </summary>
        /// <value>Restrict the query to all process instances that are top level process instances.</value>
        [DataMember(Name = "rootProcessInstances", EmitDefaultValue = true)]
        public bool? RootProcessInstances { get; set; }

        /// <summary>
        /// Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances)
        /// </summary>
        /// <value>Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances)</value>
        [DataMember(Name = "leafProcessInstances", EmitDefaultValue = true)]
        public bool? LeafProcessInstances { get; set; }

        /// <summary>
        /// A JSON array to only include process instances that have variables with certain values. The array consists of objects with the three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; (String) is the variable name, &#x60;operator&#x60; (String) is the comparison operator to be used and &#x60;value&#x60; the variable value. The &#x60;value&#x60; may be String, Number or Boolean.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;.
        /// </summary>
        /// <value>A JSON array to only include process instances that have variables with certain values. The array consists of objects with the three properties &#x60;name&#x60;, &#x60;operator&#x60; and &#x60;value&#x60;. &#x60;name&#x60; (String) is the variable name, &#x60;operator&#x60; (String) is the comparison operator to be used and &#x60;value&#x60; the variable value. The &#x60;value&#x60; may be String, Number or Boolean.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;.</value>
        [DataMember(Name = "variables", EmitDefaultValue = true)]
        public List<VariableQueryParameterDto> Variables { get; set; }

        /// <summary>
        /// Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
        /// </summary>
        /// <value>Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.</value>
        [DataMember(Name = "variableNamesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableNamesIgnoreCase { get; set; }

        /// <summary>
        /// Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
        /// </summary>
        /// <value>Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.</value>
        [DataMember(Name = "variableValuesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableValuesIgnoreCase { get; set; }

        /// <summary>
        /// A JSON array of nested process instance queries with OR semantics. A process instance matches a nested query if it fulfills at least one of the query&#39;s predicates. With multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form). All process instance query properties can be used except for: &#x60;sorting&#x60; See the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
        /// </summary>
        /// <value>A JSON array of nested process instance queries with OR semantics. A process instance matches a nested query if it fulfills at least one of the query&#39;s predicates. With multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form). All process instance query properties can be used except for: &#x60;sorting&#x60; See the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.</value>
        [DataMember(Name = "orQueries", EmitDefaultValue = true)]
        public List<ProcessInstanceQueryDto> OrQueries { get; set; }

        /// <summary>
        /// Apply sorting of the result
        /// </summary>
        /// <value>Apply sorting of the result</value>
        [DataMember(Name = "sorting", EmitDefaultValue = false)]
        public List<ProcessInstanceQueryDtoSorting> Sorting { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ProcessInstanceQueryDto {\n");
            sb.Append("  DeploymentId: ").Append(DeploymentId).Append("\n");
            sb.Append("  ProcessDefinitionId: ").Append(ProcessDefinitionId).Append("\n");
            sb.Append("  ProcessDefinitionKey: ").Append(ProcessDefinitionKey).Append("\n");
            sb.Append("  ProcessDefinitionKeyIn: ").Append(ProcessDefinitionKeyIn).Append("\n");
            sb.Append("  ProcessDefinitionKeyNotIn: ").Append(ProcessDefinitionKeyNotIn).Append("\n");
            sb.Append("  BusinessKey: ").Append(BusinessKey).Append("\n");
            sb.Append("  BusinessKeyLike: ").Append(BusinessKeyLike).Append("\n");
            sb.Append("  CaseInstanceId: ").Append(CaseInstanceId).Append("\n");
            sb.Append("  SuperProcessInstance: ").Append(SuperProcessInstance).Append("\n");
            sb.Append("  SubProcessInstance: ").Append(SubProcessInstance).Append("\n");
            sb.Append("  SuperCaseInstance: ").Append(SuperCaseInstance).Append("\n");
            sb.Append("  SubCaseInstance: ").Append(SubCaseInstance).Append("\n");
            sb.Append("  Active: ").Append(Active).Append("\n");
            sb.Append("  Suspended: ").Append(Suspended).Append("\n");
            sb.Append("  ProcessInstanceIds: ").Append(ProcessInstanceIds).Append("\n");
            sb.Append("  WithIncident: ").Append(WithIncident).Append("\n");
            sb.Append("  IncidentId: ").Append(IncidentId).Append("\n");
            sb.Append("  IncidentType: ").Append(IncidentType).Append("\n");
            sb.Append("  IncidentMessage: ").Append(IncidentMessage).Append("\n");
            sb.Append("  IncidentMessageLike: ").Append(IncidentMessageLike).Append("\n");
            sb.Append("  TenantIdIn: ").Append(TenantIdIn).Append("\n");
            sb.Append("  WithoutTenantId: ").Append(WithoutTenantId).Append("\n");
            sb.Append("  ProcessDefinitionWithoutTenantId: ").Append(ProcessDefinitionWithoutTenantId).Append("\n");
            sb.Append("  ActivityIdIn: ").Append(ActivityIdIn).Append("\n");
            sb.Append("  RootProcessInstances: ").Append(RootProcessInstances).Append("\n");
            sb.Append("  LeafProcessInstances: ").Append(LeafProcessInstances).Append("\n");
            sb.Append("  Variables: ").Append(Variables).Append("\n");
            sb.Append("  VariableNamesIgnoreCase: ").Append(VariableNamesIgnoreCase).Append("\n");
            sb.Append("  VariableValuesIgnoreCase: ").Append(VariableValuesIgnoreCase).Append("\n");
            sb.Append("  OrQueries: ").Append(OrQueries).Append("\n");
            sb.Append("  Sorting: ").Append(Sorting).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ProcessInstanceQueryDto);
        }

        /// <summary>
        /// Returns true if ProcessInstanceQueryDto instances are equal
        /// </summary>
        /// <param name="input">Instance of ProcessInstanceQueryDto to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ProcessInstanceQueryDto input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.DeploymentId == input.DeploymentId ||
                    (this.DeploymentId != null &&
                    this.DeploymentId.Equals(input.DeploymentId))
                ) && 
                (
                    this.ProcessDefinitionId == input.ProcessDefinitionId ||
                    (this.ProcessDefinitionId != null &&
                    this.ProcessDefinitionId.Equals(input.ProcessDefinitionId))
                ) && 
                (
                    this.ProcessDefinitionKey == input.ProcessDefinitionKey ||
                    (this.ProcessDefinitionKey != null &&
                    this.ProcessDefinitionKey.Equals(input.ProcessDefinitionKey))
                ) && 
                (
                    this.ProcessDefinitionKeyIn == input.ProcessDefinitionKeyIn ||
                    this.ProcessDefinitionKeyIn != null &&
                    input.ProcessDefinitionKeyIn != null &&
                    this.ProcessDefinitionKeyIn.SequenceEqual(input.ProcessDefinitionKeyIn)
                ) && 
                (
                    this.ProcessDefinitionKeyNotIn == input.ProcessDefinitionKeyNotIn ||
                    this.ProcessDefinitionKeyNotIn != null &&
                    input.ProcessDefinitionKeyNotIn != null &&
                    this.ProcessDefinitionKeyNotIn.SequenceEqual(input.ProcessDefinitionKeyNotIn)
                ) && 
                (
                    this.BusinessKey == input.BusinessKey ||
                    (this.BusinessKey != null &&
                    this.BusinessKey.Equals(input.BusinessKey))
                ) && 
                (
                    this.BusinessKeyLike == input.BusinessKeyLike ||
                    (this.BusinessKeyLike != null &&
                    this.BusinessKeyLike.Equals(input.BusinessKeyLike))
                ) && 
                (
                    this.CaseInstanceId == input.CaseInstanceId ||
                    (this.CaseInstanceId != null &&
                    this.CaseInstanceId.Equals(input.CaseInstanceId))
                ) && 
                (
                    this.SuperProcessInstance == input.SuperProcessInstance ||
                    (this.SuperProcessInstance != null &&
                    this.SuperProcessInstance.Equals(input.SuperProcessInstance))
                ) && 
                (
                    this.SubProcessInstance == input.SubProcessInstance ||
                    (this.SubProcessInstance != null &&
                    this.SubProcessInstance.Equals(input.SubProcessInstance))
                ) && 
                (
                    this.SuperCaseInstance == input.SuperCaseInstance ||
                    (this.SuperCaseInstance != null &&
                    this.SuperCaseInstance.Equals(input.SuperCaseInstance))
                ) && 
                (
                    this.SubCaseInstance == input.SubCaseInstance ||
                    (this.SubCaseInstance != null &&
                    this.SubCaseInstance.Equals(input.SubCaseInstance))
                ) && 
                (
                    this.Active == input.Active ||
                    (this.Active != null &&
                    this.Active.Equals(input.Active))
                ) && 
                (
                    this.Suspended == input.Suspended ||
                    (this.Suspended != null &&
                    this.Suspended.Equals(input.Suspended))
                ) && 
                (
                    this.ProcessInstanceIds == input.ProcessInstanceIds ||
                    this.ProcessInstanceIds != null &&
                    input.ProcessInstanceIds != null &&
                    this.ProcessInstanceIds.SequenceEqual(input.ProcessInstanceIds)
                ) && 
                (
                    this.WithIncident == input.WithIncident ||
                    (this.WithIncident != null &&
                    this.WithIncident.Equals(input.WithIncident))
                ) && 
                (
                    this.IncidentId == input.IncidentId ||
                    (this.IncidentId != null &&
                    this.IncidentId.Equals(input.IncidentId))
                ) && 
                (
                    this.IncidentType == input.IncidentType ||
                    (this.IncidentType != null &&
                    this.IncidentType.Equals(input.IncidentType))
                ) && 
                (
                    this.IncidentMessage == input.IncidentMessage ||
                    (this.IncidentMessage != null &&
                    this.IncidentMessage.Equals(input.IncidentMessage))
                ) && 
                (
                    this.IncidentMessageLike == input.IncidentMessageLike ||
                    (this.IncidentMessageLike != null &&
                    this.IncidentMessageLike.Equals(input.IncidentMessageLike))
                ) && 
                (
                    this.TenantIdIn == input.TenantIdIn ||
                    this.TenantIdIn != null &&
                    input.TenantIdIn != null &&
                    this.TenantIdIn.SequenceEqual(input.TenantIdIn)
                ) && 
                (
                    this.WithoutTenantId == input.WithoutTenantId ||
                    (this.WithoutTenantId != null &&
                    this.WithoutTenantId.Equals(input.WithoutTenantId))
                ) && 
                (
                    this.ProcessDefinitionWithoutTenantId == input.ProcessDefinitionWithoutTenantId ||
                    (this.ProcessDefinitionWithoutTenantId != null &&
                    this.ProcessDefinitionWithoutTenantId.Equals(input.ProcessDefinitionWithoutTenantId))
                ) && 
                (
                    this.ActivityIdIn == input.ActivityIdIn ||
                    this.ActivityIdIn != null &&
                    input.ActivityIdIn != null &&
                    this.ActivityIdIn.SequenceEqual(input.ActivityIdIn)
                ) && 
                (
                    this.RootProcessInstances == input.RootProcessInstances ||
                    (this.RootProcessInstances != null &&
                    this.RootProcessInstances.Equals(input.RootProcessInstances))
                ) && 
                (
                    this.LeafProcessInstances == input.LeafProcessInstances ||
                    (this.LeafProcessInstances != null &&
                    this.LeafProcessInstances.Equals(input.LeafProcessInstances))
                ) && 
                (
                    this.Variables == input.Variables ||
                    this.Variables != null &&
                    input.Variables != null &&
                    this.Variables.SequenceEqual(input.Variables)
                ) && 
                (
                    this.VariableNamesIgnoreCase == input.VariableNamesIgnoreCase ||
                    (this.VariableNamesIgnoreCase != null &&
                    this.VariableNamesIgnoreCase.Equals(input.VariableNamesIgnoreCase))
                ) && 
                (
                    this.VariableValuesIgnoreCase == input.VariableValuesIgnoreCase ||
                    (this.VariableValuesIgnoreCase != null &&
                    this.VariableValuesIgnoreCase.Equals(input.VariableValuesIgnoreCase))
                ) && 
                (
                    this.OrQueries == input.OrQueries ||
                    this.OrQueries != null &&
                    input.OrQueries != null &&
                    this.OrQueries.SequenceEqual(input.OrQueries)
                ) && 
                (
                    this.Sorting == input.Sorting ||
                    this.Sorting != null &&
                    input.Sorting != null &&
                    this.Sorting.SequenceEqual(input.Sorting)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.DeploymentId != null)
                    hashCode = hashCode * 59 + this.DeploymentId.GetHashCode();
                if (this.ProcessDefinitionId != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionId.GetHashCode();
                if (this.ProcessDefinitionKey != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionKey.GetHashCode();
                if (this.ProcessDefinitionKeyIn != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionKeyIn.GetHashCode();
                if (this.ProcessDefinitionKeyNotIn != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionKeyNotIn.GetHashCode();
                if (this.BusinessKey != null)
                    hashCode = hashCode * 59 + this.BusinessKey.GetHashCode();
                if (this.BusinessKeyLike != null)
                    hashCode = hashCode * 59 + this.BusinessKeyLike.GetHashCode();
                if (this.CaseInstanceId != null)
                    hashCode = hashCode * 59 + this.CaseInstanceId.GetHashCode();
                if (this.SuperProcessInstance != null)
                    hashCode = hashCode * 59 + this.SuperProcessInstance.GetHashCode();
                if (this.SubProcessInstance != null)
                    hashCode = hashCode * 59 + this.SubProcessInstance.GetHashCode();
                if (this.SuperCaseInstance != null)
                    hashCode = hashCode * 59 + this.SuperCaseInstance.GetHashCode();
                if (this.SubCaseInstance != null)
                    hashCode = hashCode * 59 + this.SubCaseInstance.GetHashCode();
                if (this.Active != null)
                    hashCode = hashCode * 59 + this.Active.GetHashCode();
                if (this.Suspended != null)
                    hashCode = hashCode * 59 + this.Suspended.GetHashCode();
                if (this.ProcessInstanceIds != null)
                    hashCode = hashCode * 59 + this.ProcessInstanceIds.GetHashCode();
                if (this.WithIncident != null)
                    hashCode = hashCode * 59 + this.WithIncident.GetHashCode();
                if (this.IncidentId != null)
                    hashCode = hashCode * 59 + this.IncidentId.GetHashCode();
                if (this.IncidentType != null)
                    hashCode = hashCode * 59 + this.IncidentType.GetHashCode();
                if (this.IncidentMessage != null)
                    hashCode = hashCode * 59 + this.IncidentMessage.GetHashCode();
                if (this.IncidentMessageLike != null)
                    hashCode = hashCode * 59 + this.IncidentMessageLike.GetHashCode();
                if (this.TenantIdIn != null)
                    hashCode = hashCode * 59 + this.TenantIdIn.GetHashCode();
                if (this.WithoutTenantId != null)
                    hashCode = hashCode * 59 + this.WithoutTenantId.GetHashCode();
                if (this.ProcessDefinitionWithoutTenantId != null)
                    hashCode = hashCode * 59 + this.ProcessDefinitionWithoutTenantId.GetHashCode();
                if (this.ActivityIdIn != null)
                    hashCode = hashCode * 59 + this.ActivityIdIn.GetHashCode();
                if (this.RootProcessInstances != null)
                    hashCode = hashCode * 59 + this.RootProcessInstances.GetHashCode();
                if (this.LeafProcessInstances != null)
                    hashCode = hashCode * 59 + this.LeafProcessInstances.GetHashCode();
                if (this.Variables != null)
                    hashCode = hashCode * 59 + this.Variables.GetHashCode();
                if (this.VariableNamesIgnoreCase != null)
                    hashCode = hashCode * 59 + this.VariableNamesIgnoreCase.GetHashCode();
                if (this.VariableValuesIgnoreCase != null)
                    hashCode = hashCode * 59 + this.VariableValuesIgnoreCase.GetHashCode();
                if (this.OrQueries != null)
                    hashCode = hashCode * 59 + this.OrQueries.GetHashCode();
                if (this.Sorting != null)
                    hashCode = hashCode * 59 + this.Sorting.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
