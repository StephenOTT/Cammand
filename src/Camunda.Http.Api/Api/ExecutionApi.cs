/*
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.16.0-alpha1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Camunda.Http.Api.Client;
using Camunda.Http.Api.Model;

namespace Camunda.Http.Api.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IExecutionApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create Incident
        /// </summary>
        /// <remarks>
        /// Creates a custom incident with given properties.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <returns>IncidentDto</returns>
        IncidentDto CreateIncident(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto));

        /// <summary>
        /// Create Incident
        /// </summary>
        /// <remarks>
        /// Creates a custom incident with given properties.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <returns>ApiResponse of IncidentDto</returns>
        ApiResponse<IncidentDto> CreateIncidentWithHttpInfo(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto));
        /// <summary>
        /// Delete Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns></returns>
        void DeleteLocalExecutionVariable(string id, string varName);

        /// <summary>
        /// Delete Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteLocalExecutionVariableWithHttpInfo(string id, string varName);
        /// <summary>
        /// Get Execution
        /// </summary>
        /// <remarks>
        /// Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <returns>ExecutionDto</returns>
        ExecutionDto GetExecution(string id);

        /// <summary>
        /// Get Execution
        /// </summary>
        /// <remarks>
        /// Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <returns>ApiResponse of ExecutionDto</returns>
        ApiResponse<ExecutionDto> GetExecutionWithHttpInfo(string id);
        /// <summary>
        /// Get Executions
        /// </summary>
        /// <remarks>
        /// Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>List&lt;ExecutionDto&gt;</returns>
        List<ExecutionDto> GetExecutions(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?));

        /// <summary>
        /// Get Executions
        /// </summary>
        /// <remarks>
        /// Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>ApiResponse of List&lt;ExecutionDto&gt;</returns>
        ApiResponse<List<ExecutionDto>> GetExecutionsWithHttpInfo(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?));
        /// <summary>
        /// Get Execution Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <returns>CountResultDto</returns>
        CountResultDto GetExecutionsCount(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?));

        /// <summary>
        /// Get Execution Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        ApiResponse<CountResultDto> GetExecutionsCountWithHttpInfo(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?));
        /// <summary>
        /// Get Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>VariableValueDto</returns>
        VariableValueDto GetLocalExecutionVariable(string id, string varName, bool? deserializeValue = default(bool?));

        /// <summary>
        /// Get Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>ApiResponse of VariableValueDto</returns>
        ApiResponse<VariableValueDto> GetLocalExecutionVariableWithHttpInfo(string id, string varName, bool? deserializeValue = default(bool?));
        /// <summary>
        /// Get Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <returns>System.IO.Stream</returns>
        System.IO.Stream GetLocalExecutionVariableBinary(string id, string varName);

        /// <summary>
        /// Get Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        ApiResponse<System.IO.Stream> GetLocalExecutionVariableBinaryWithHttpInfo(string id, string varName);
        /// <summary>
        /// Get Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>Dictionary&lt;string, VariableValueDto&gt;</returns>
        Dictionary<string, VariableValueDto> GetLocalExecutionVariables(string id, bool? deserializeValues = default(bool?));

        /// <summary>
        /// Get Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, VariableValueDto&gt;</returns>
        ApiResponse<Dictionary<string, VariableValueDto>> GetLocalExecutionVariablesWithHttpInfo(string id, bool? deserializeValues = default(bool?));
        /// <summary>
        /// Get Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Retrieves a message event subscription for a given execution by id and a message name.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <returns>EventSubscriptionDto</returns>
        EventSubscriptionDto GetMessageEventSubscription(string id, string messageName);

        /// <summary>
        /// Get Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Retrieves a message event subscription for a given execution by id and a message name.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <returns>ApiResponse of EventSubscriptionDto</returns>
        ApiResponse<EventSubscriptionDto> GetMessageEventSubscriptionWithHttpInfo(string id, string messageName);
        /// <summary>
        /// Update/Delete Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns></returns>
        void ModifyLocalExecutionVariables(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto));

        /// <summary>
        /// Update/Delete Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ModifyLocalExecutionVariablesWithHttpInfo(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto));
        /// <summary>
        /// Put Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns></returns>
        void PutLocalExecutionVariable(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto));

        /// <summary>
        /// Put Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> PutLocalExecutionVariableWithHttpInfo(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto));
        /// <summary>
        /// Get Executions (POST)
        /// </summary>
        /// <remarks>
        /// Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>List&lt;ExecutionDto&gt;</returns>
        List<ExecutionDto> QueryExecutions(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto));

        /// <summary>
        /// Get Executions (POST)
        /// </summary>
        /// <remarks>
        /// Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>ApiResponse of List&lt;ExecutionDto&gt;</returns>
        ApiResponse<List<ExecutionDto>> QueryExecutionsWithHttpInfo(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto));
        /// <summary>
        /// Get Execution Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>CountResultDto</returns>
        CountResultDto QueryExecutionsCount(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto));

        /// <summary>
        /// Get Execution Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        ApiResponse<CountResultDto> QueryExecutionsCountWithHttpInfo(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto));
        /// <summary>
        /// Post Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns></returns>
        void SetLocalExecutionVariableBinary(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string));

        /// <summary>
        /// Post Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetLocalExecutionVariableBinaryWithHttpInfo(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string));
        /// <summary>
        /// Trigger Execution
        /// </summary>
        /// <remarks>
        /// Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns></returns>
        void SignalExecution(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto));

        /// <summary>
        /// Trigger Execution
        /// </summary>
        /// <remarks>
        /// Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SignalExecutionWithHttpInfo(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto));
        /// <summary>
        /// Trigger Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns></returns>
        void TriggerEvent(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto));

        /// <summary>
        /// Trigger Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> TriggerEventWithHttpInfo(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IExecutionApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Create Incident
        /// </summary>
        /// <remarks>
        /// Creates a custom incident with given properties.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IncidentDto</returns>
        System.Threading.Tasks.Task<IncidentDto> CreateIncidentAsync(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create Incident
        /// </summary>
        /// <remarks>
        /// Creates a custom incident with given properties.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IncidentDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<IncidentDto>> CreateIncidentWithHttpInfoAsync(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteLocalExecutionVariableAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteLocalExecutionVariableWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Execution
        /// </summary>
        /// <remarks>
        /// Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ExecutionDto</returns>
        System.Threading.Tasks.Task<ExecutionDto> GetExecutionAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Execution
        /// </summary>
        /// <remarks>
        /// Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ExecutionDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ExecutionDto>> GetExecutionWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Executions
        /// </summary>
        /// <remarks>
        /// Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ExecutionDto&gt;</returns>
        System.Threading.Tasks.Task<List<ExecutionDto>> GetExecutionsAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Executions
        /// </summary>
        /// <remarks>
        /// Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ExecutionDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ExecutionDto>>> GetExecutionsWithHttpInfoAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Execution Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        System.Threading.Tasks.Task<CountResultDto> GetExecutionsCountAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Execution Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountResultDto>> GetExecutionsCountWithHttpInfoAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VariableValueDto</returns>
        System.Threading.Tasks.Task<VariableValueDto> GetLocalExecutionVariableAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VariableValueDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<VariableValueDto>> GetLocalExecutionVariableWithHttpInfoAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        System.Threading.Tasks.Task<System.IO.Stream> GetLocalExecutionVariableBinaryAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        System.Threading.Tasks.Task<ApiResponse<System.IO.Stream>> GetLocalExecutionVariableBinaryWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dictionary&lt;string, VariableValueDto&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, VariableValueDto>> GetLocalExecutionVariablesAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, VariableValueDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dictionary<string, VariableValueDto>>> GetLocalExecutionVariablesWithHttpInfoAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Retrieves a message event subscription for a given execution by id and a message name.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventSubscriptionDto</returns>
        System.Threading.Tasks.Task<EventSubscriptionDto> GetMessageEventSubscriptionAsync(string id, string messageName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Retrieves a message event subscription for a given execution by id and a message name.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventSubscriptionDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventSubscriptionDto>> GetMessageEventSubscriptionWithHttpInfoAsync(string id, string messageName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update/Delete Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ModifyLocalExecutionVariablesAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update/Delete Local Execution Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ModifyLocalExecutionVariablesWithHttpInfoAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Put Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task PutLocalExecutionVariableAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Put Local Execution Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PutLocalExecutionVariableWithHttpInfoAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Executions (POST)
        /// </summary>
        /// <remarks>
        /// Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ExecutionDto&gt;</returns>
        System.Threading.Tasks.Task<List<ExecutionDto>> QueryExecutionsAsync(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Executions (POST)
        /// </summary>
        /// <remarks>
        /// Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ExecutionDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ExecutionDto>>> QueryExecutionsWithHttpInfoAsync(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Execution Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        System.Threading.Tasks.Task<CountResultDto> QueryExecutionsCountAsync(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Execution Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountResultDto>> QueryExecutionsCountWithHttpInfoAsync(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Post Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetLocalExecutionVariableBinaryAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Post Local Execution Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetLocalExecutionVariableBinaryWithHttpInfoAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Trigger Execution
        /// </summary>
        /// <remarks>
        /// Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SignalExecutionAsync(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Trigger Execution
        /// </summary>
        /// <remarks>
        /// Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SignalExecutionWithHttpInfoAsync(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Trigger Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task TriggerEventAsync(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Trigger Message Event Subscription
        /// </summary>
        /// <remarks>
        /// Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </remarks>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> TriggerEventWithHttpInfoAsync(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IExecutionApi : IExecutionApiSync, IExecutionApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ExecutionApi : IDisposable, IExecutionApi
    {
        private Camunda.Http.Api.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecutionApi"/> class.
        /// **IMPORTANT** This will also create an istance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHander</see>.
        /// </summary>
        /// <returns></returns>
        public ExecutionApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecutionApi"/> class.
        /// **IMPORTANT** This will also create an istance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHander</see>.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public ExecutionApi(String basePath)
        {
            this.Configuration = Camunda.Http.Api.Client.Configuration.MergeConfigurations(
                Camunda.Http.Api.Client.GlobalConfiguration.Instance,
                new Camunda.Http.Api.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Camunda.Http.Api.Client.ApiClient(this.Configuration.BasePath);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Camunda.Http.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecutionApi"/> class using Configuration object.
        /// **IMPORTANT** This will also create an istance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHander</see>.
        /// </summary>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public ExecutionApi(Camunda.Http.Api.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Camunda.Http.Api.Client.Configuration.MergeConfigurations(
                Camunda.Http.Api.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Camunda.Http.Api.Client.ApiClient(this.Configuration.BasePath);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Camunda.Http.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecutionApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ExecutionApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecutionApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ExecutionApi(HttpClient client, String basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = Camunda.Http.Api.Client.Configuration.MergeConfigurations(
                Camunda.Http.Api.Client.GlobalConfiguration.Instance,
                new Camunda.Http.Api.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Camunda.Http.Api.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Camunda.Http.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecutionApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ExecutionApi(HttpClient client, Camunda.Http.Api.Client.Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = Camunda.Http.Api.Client.Configuration.MergeConfigurations(
                Camunda.Http.Api.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Camunda.Http.Api.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Camunda.Http.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecutionApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public ExecutionApi(Camunda.Http.Api.Client.ISynchronousClient client, Camunda.Http.Api.Client.IAsynchronousClient asyncClient, Camunda.Http.Api.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Camunda.Http.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Disposes resources if they were created by us
        /// </summary>
        public void Dispose()
        {
            this.ApiClient?.Dispose();
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public Camunda.Http.Api.Client.ApiClient ApiClient { get; set; } = null;

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Camunda.Http.Api.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Camunda.Http.Api.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Camunda.Http.Api.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Camunda.Http.Api.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Create Incident Creates a custom incident with given properties.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <returns>IncidentDto</returns>
        public IncidentDto CreateIncident(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto))
        {
            Camunda.Http.Api.Client.ApiResponse<IncidentDto> localVarResponse = CreateIncidentWithHttpInfo(id, createIncidentDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Incident Creates a custom incident with given properties.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <returns>ApiResponse of IncidentDto</returns>
        public Camunda.Http.Api.Client.ApiResponse<IncidentDto> CreateIncidentWithHttpInfo(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->CreateIncident");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = createIncidentDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<IncidentDto>("/execution/{id}/create-incident", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIncident", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create Incident Creates a custom incident with given properties.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IncidentDto</returns>
        public async System.Threading.Tasks.Task<IncidentDto> CreateIncidentAsync(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<IncidentDto> localVarResponse = await CreateIncidentWithHttpInfoAsync(id, createIncidentDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Incident Creates a custom incident with given properties.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to create a new incident for.</param>
        /// <param name="createIncidentDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IncidentDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<IncidentDto>> CreateIncidentWithHttpInfoAsync(string id, CreateIncidentDto createIncidentDto = default(CreateIncidentDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->CreateIncident");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = createIncidentDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<IncidentDto>("/execution/{id}/create-incident", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIncident", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Local Execution Variable Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns></returns>
        public void DeleteLocalExecutionVariable(string id, string varName)
        {
            DeleteLocalExecutionVariableWithHttpInfo(id, varName);
        }

        /// <summary>
        /// Delete Local Execution Variable Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.Http.Api.Client.ApiResponse<Object> DeleteLocalExecutionVariableWithHttpInfo(string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->DeleteLocalExecutionVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->DeleteLocalExecutionVariable");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/execution/{id}/localVariables/{varName}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLocalExecutionVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Local Execution Variable Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteLocalExecutionVariableAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteLocalExecutionVariableWithHttpInfoAsync(id, varName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete Local Execution Variable Deletes a variable in the context of a given execution by id. Deletion does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<Object>> DeleteLocalExecutionVariableWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->DeleteLocalExecutionVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->DeleteLocalExecutionVariable");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/execution/{id}/localVariables/{varName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteLocalExecutionVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Execution Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <returns>ExecutionDto</returns>
        public ExecutionDto GetExecution(string id)
        {
            Camunda.Http.Api.Client.ApiResponse<ExecutionDto> localVarResponse = GetExecutionWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Execution Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <returns>ApiResponse of ExecutionDto</returns>
        public Camunda.Http.Api.Client.ApiResponse<ExecutionDto> GetExecutionWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetExecution");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<ExecutionDto>("/execution/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetExecution", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Execution Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ExecutionDto</returns>
        public async System.Threading.Tasks.Task<ExecutionDto> GetExecutionAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<ExecutionDto> localVarResponse = await GetExecutionWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Execution Retrieves an execution by id, according to the &#x60;Execution&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ExecutionDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<ExecutionDto>> GetExecutionWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetExecution");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ExecutionDto>("/execution/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetExecution", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Executions Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>List&lt;ExecutionDto&gt;</returns>
        public List<ExecutionDto> GetExecutions(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?))
        {
            Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>> localVarResponse = GetExecutionsWithHttpInfo(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, sortBy, sortOrder, firstResult, maxResults);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Executions Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <returns>ApiResponse of List&lt;ExecutionDto&gt;</returns>
        public Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>> GetExecutionsWithHttpInfo(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?))
        {
            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processInstanceId", processInstanceId));
            }
            if (activityId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "activityId", activityId));
            }
            if (signalEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "signalEventSubscriptionName", signalEventSubscriptionName));
            }
            if (messageEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "messageEventSubscriptionName", messageEventSubscriptionName));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (processVariables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processVariables", processVariables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "sortBy", sortBy));
            }
            if (sortOrder != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "sortOrder", sortOrder));
            }
            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ExecutionDto>>("/execution", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetExecutions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Executions Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ExecutionDto&gt;</returns>
        public async System.Threading.Tasks.Task<List<ExecutionDto>> GetExecutionsAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>> localVarResponse = await GetExecutionsWithHttpInfoAsync(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, sortBy, sortOrder, firstResult, maxResults, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Executions Queries for the executions that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ExecutionDto&gt;)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>>> GetExecutionsWithHttpInfoAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processInstanceId", processInstanceId));
            }
            if (activityId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "activityId", activityId));
            }
            if (signalEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "signalEventSubscriptionName", signalEventSubscriptionName));
            }
            if (messageEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "messageEventSubscriptionName", messageEventSubscriptionName));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (processVariables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processVariables", processVariables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "sortBy", sortBy));
            }
            if (sortOrder != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "sortOrder", sortOrder));
            }
            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ExecutionDto>>("/execution", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetExecutions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Execution Count Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <returns>CountResultDto</returns>
        public CountResultDto GetExecutionsCount(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?))
        {
            Camunda.Http.Api.Client.ApiResponse<CountResultDto> localVarResponse = GetExecutionsCountWithHttpInfo(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Execution Count Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        public Camunda.Http.Api.Client.ApiResponse<CountResultDto> GetExecutionsCountWithHttpInfo(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?))
        {
            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processInstanceId", processInstanceId));
            }
            if (activityId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "activityId", activityId));
            }
            if (signalEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "signalEventSubscriptionName", signalEventSubscriptionName));
            }
            if (messageEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "messageEventSubscriptionName", messageEventSubscriptionName));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (processVariables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processVariables", processVariables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<CountResultDto>("/execution/count", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetExecutionsCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Execution Count Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        public async System.Threading.Tasks.Task<CountResultDto> GetExecutionsCountAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<CountResultDto> localVarResponse = await GetExecutionsCountWithHttpInfoAsync(businessKey, processDefinitionId, processDefinitionKey, processInstanceId, activityId, signalEventSubscriptionName, messageEventSubscriptionName, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, variables, processVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Execution Count Queries for the number of executions that fulfill given parameters. Takes the same parameters as the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="businessKey">Filter by the business key of the process instances the executions belong to. (optional)</param>
        /// <param name="processDefinitionId">Filter by the process definition the executions run on. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the executions run on. (optional)</param>
        /// <param name="processInstanceId">Filter by the id of the process instance the execution belongs to. (optional)</param>
        /// <param name="activityId">Filter by the id of the activity the execution currently executes. (optional)</param>
        /// <param name="signalEventSubscriptionName">Select only those executions that expect a signal of the given name. (optional)</param>
        /// <param name="messageEventSubscriptionName">Select only those executions that expect a message of the given name. (optional)</param>
        /// <param name="active">Only include active executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="suspended">Only include suspended executions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](/manual/develop/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. An execution must have one of the given tenant ids. (optional)</param>
        /// <param name="variables">Only include executions that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="processVariables">Only include executions that belong to a process instance with variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.  Valid operator values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values provided in &#x60;variables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<CountResultDto>> GetExecutionsCountWithHttpInfoAsync(string businessKey = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processInstanceId = default(string), string activityId = default(string), string signalEventSubscriptionName = default(string), string messageEventSubscriptionName = default(string), bool? active = default(bool?), bool? suspended = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), string variables = default(string), string processVariables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processInstanceId", processInstanceId));
            }
            if (activityId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "activityId", activityId));
            }
            if (signalEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "signalEventSubscriptionName", signalEventSubscriptionName));
            }
            if (messageEventSubscriptionName != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "messageEventSubscriptionName", messageEventSubscriptionName));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (processVariables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "processVariables", processVariables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<CountResultDto>("/execution/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetExecutionsCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Local Execution Variable Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>VariableValueDto</returns>
        public VariableValueDto GetLocalExecutionVariable(string id, string varName, bool? deserializeValue = default(bool?))
        {
            Camunda.Http.Api.Client.ApiResponse<VariableValueDto> localVarResponse = GetLocalExecutionVariableWithHttpInfo(id, varName, deserializeValue);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Local Execution Variable Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>ApiResponse of VariableValueDto</returns>
        public Camunda.Http.Api.Client.ApiResponse<VariableValueDto> GetLocalExecutionVariableWithHttpInfo(string id, string varName, bool? deserializeValue = default(bool?))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetLocalExecutionVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->GetLocalExecutionVariable");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (deserializeValue != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "deserializeValue", deserializeValue));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<VariableValueDto>("/execution/{id}/localVariables/{varName}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLocalExecutionVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Local Execution Variable Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VariableValueDto</returns>
        public async System.Threading.Tasks.Task<VariableValueDto> GetLocalExecutionVariableAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<VariableValueDto> localVarResponse = await GetLocalExecutionVariableWithHttpInfoAsync(id, varName, deserializeValue, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Local Execution Variable Retrieves a variable from the context of a given execution by id. Does not traverse the parent execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath. If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VariableValueDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<VariableValueDto>> GetLocalExecutionVariableWithHttpInfoAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetLocalExecutionVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->GetLocalExecutionVariable");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (deserializeValue != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "deserializeValue", deserializeValue));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<VariableValueDto>("/execution/{id}/localVariables/{varName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLocalExecutionVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Local Execution Variable (Binary) Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <returns>System.IO.Stream</returns>
        public System.IO.Stream GetLocalExecutionVariableBinary(string id, string varName)
        {
            Camunda.Http.Api.Client.ApiResponse<System.IO.Stream> localVarResponse = GetLocalExecutionVariableBinaryWithHttpInfo(id, varName);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Local Execution Variable (Binary) Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        public Camunda.Http.Api.Client.ApiResponse<System.IO.Stream> GetLocalExecutionVariableBinaryWithHttpInfo(string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetLocalExecutionVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->GetLocalExecutionVariableBinary");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/octet-stream",
                "text/plain",
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<System.IO.Stream>("/execution/{id}/localVariables/{varName}/data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLocalExecutionVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Local Execution Variable (Binary) Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        public async System.Threading.Tasks.Task<System.IO.Stream> GetLocalExecutionVariableBinaryAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<System.IO.Stream> localVarResponse = await GetLocalExecutionVariableBinaryWithHttpInfoAsync(id, varName, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Local Execution Variable (Binary) Retrieves a binary variable from the context of a given execution by id. Does not traverse the parent execution hierarchy. Applicable for byte array and file variables.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variable from.</param>
        /// <param name="varName">The name of the variable to get.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<System.IO.Stream>> GetLocalExecutionVariableBinaryWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetLocalExecutionVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->GetLocalExecutionVariableBinary");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/octet-stream",
                "text/plain",
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<System.IO.Stream>("/execution/{id}/localVariables/{varName}/data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLocalExecutionVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Local Execution Variables Retrieves all variables of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>Dictionary&lt;string, VariableValueDto&gt;</returns>
        public Dictionary<string, VariableValueDto> GetLocalExecutionVariables(string id, bool? deserializeValues = default(bool?))
        {
            Camunda.Http.Api.Client.ApiResponse<Dictionary<string, VariableValueDto>> localVarResponse = GetLocalExecutionVariablesWithHttpInfo(id, deserializeValues);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Local Execution Variables Retrieves all variables of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, VariableValueDto&gt;</returns>
        public Camunda.Http.Api.Client.ApiResponse<Dictionary<string, VariableValueDto>> GetLocalExecutionVariablesWithHttpInfo(string id, bool? deserializeValues = default(bool?))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetLocalExecutionVariables");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (deserializeValues != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "deserializeValues", deserializeValues));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<Dictionary<string, VariableValueDto>>("/execution/{id}/localVariables", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLocalExecutionVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Local Execution Variables Retrieves all variables of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dictionary&lt;string, VariableValueDto&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, VariableValueDto>> GetLocalExecutionVariablesAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<Dictionary<string, VariableValueDto>> localVarResponse = await GetLocalExecutionVariablesWithHttpInfoAsync(id, deserializeValues, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Local Execution Variables Retrieves all variables of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, VariableValueDto&gt;)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<Dictionary<string, VariableValueDto>>> GetLocalExecutionVariablesWithHttpInfoAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetLocalExecutionVariables");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (deserializeValues != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "deserializeValues", deserializeValues));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Dictionary<string, VariableValueDto>>("/execution/{id}/localVariables", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLocalExecutionVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Message Event Subscription Retrieves a message event subscription for a given execution by id and a message name.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <returns>EventSubscriptionDto</returns>
        public EventSubscriptionDto GetMessageEventSubscription(string id, string messageName)
        {
            Camunda.Http.Api.Client.ApiResponse<EventSubscriptionDto> localVarResponse = GetMessageEventSubscriptionWithHttpInfo(id, messageName);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Message Event Subscription Retrieves a message event subscription for a given execution by id and a message name.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <returns>ApiResponse of EventSubscriptionDto</returns>
        public Camunda.Http.Api.Client.ApiResponse<EventSubscriptionDto> GetMessageEventSubscriptionWithHttpInfo(string id, string messageName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetMessageEventSubscription");

            // verify the required parameter 'messageName' is set
            if (messageName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'messageName' when calling ExecutionApi->GetMessageEventSubscription");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(messageName)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<EventSubscriptionDto>("/execution/{id}/messageSubscriptions/{messageName}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageEventSubscription", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Message Event Subscription Retrieves a message event subscription for a given execution by id and a message name.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EventSubscriptionDto</returns>
        public async System.Threading.Tasks.Task<EventSubscriptionDto> GetMessageEventSubscriptionAsync(string id, string messageName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<EventSubscriptionDto> localVarResponse = await GetMessageEventSubscriptionWithHttpInfoAsync(id, messageName, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Message Event Subscription Retrieves a message event subscription for a given execution by id and a message name.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution that holds the subscription.</param>
        /// <param name="messageName">The name of the message that the subscription corresponds to.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EventSubscriptionDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<EventSubscriptionDto>> GetMessageEventSubscriptionWithHttpInfoAsync(string id, string messageName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->GetMessageEventSubscription");

            // verify the required parameter 'messageName' is set
            if (messageName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'messageName' when calling ExecutionApi->GetMessageEventSubscription");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(messageName)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<EventSubscriptionDto>("/execution/{id}/messageSubscriptions/{messageName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMessageEventSubscription", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update/Delete Local Execution Variables Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns></returns>
        public void ModifyLocalExecutionVariables(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto))
        {
            ModifyLocalExecutionVariablesWithHttpInfo(id, patchVariablesDto);
        }

        /// <summary>
        /// Update/Delete Local Execution Variables Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.Http.Api.Client.ApiResponse<Object> ModifyLocalExecutionVariablesWithHttpInfo(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->ModifyLocalExecutionVariables");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = patchVariablesDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/execution/{id}/localVariables", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyLocalExecutionVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update/Delete Local Execution Variables Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ModifyLocalExecutionVariablesAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ModifyLocalExecutionVariablesWithHttpInfoAsync(id, patchVariablesDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Update/Delete Local Execution Variables Updates or deletes the variables in the context of an execution by id. The updates do not propagate upwards in the execution hierarchy. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<Object>> ModifyLocalExecutionVariablesWithHttpInfoAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->ModifyLocalExecutionVariables");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = patchVariablesDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/execution/{id}/localVariables", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyLocalExecutionVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Put Local Execution Variable Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns></returns>
        public void PutLocalExecutionVariable(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto))
        {
            PutLocalExecutionVariableWithHttpInfo(id, varName, variableValueDto);
        }

        /// <summary>
        /// Put Local Execution Variable Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.Http.Api.Client.ApiResponse<Object> PutLocalExecutionVariableWithHttpInfo(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->PutLocalExecutionVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->PutLocalExecutionVariable");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter
            localVarRequestOptions.Data = variableValueDto;


            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/execution/{id}/localVariables/{varName}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PutLocalExecutionVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Put Local Execution Variable Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task PutLocalExecutionVariableAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await PutLocalExecutionVariableWithHttpInfoAsync(id, varName, variableValueDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Put Local Execution Variable Sets a variable in the context of a given execution by id. Update does not propagate upwards in the execution hierarchy.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<Object>> PutLocalExecutionVariableWithHttpInfoAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->PutLocalExecutionVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->PutLocalExecutionVariable");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter
            localVarRequestOptions.Data = variableValueDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/execution/{id}/localVariables/{varName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PutLocalExecutionVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Executions (POST) Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>List&lt;ExecutionDto&gt;</returns>
        public List<ExecutionDto> QueryExecutions(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto))
        {
            Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>> localVarResponse = QueryExecutionsWithHttpInfo(firstResult, maxResults, executionQueryDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Executions (POST) Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>ApiResponse of List&lt;ExecutionDto&gt;</returns>
        public Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>> QueryExecutionsWithHttpInfo(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto))
        {
            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }
            localVarRequestOptions.Data = executionQueryDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<List<ExecutionDto>>("/execution", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryExecutions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Executions (POST) Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ExecutionDto&gt;</returns>
        public async System.Threading.Tasks.Task<List<ExecutionDto>> QueryExecutionsAsync(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>> localVarResponse = await QueryExecutionsWithHttpInfoAsync(firstResult, maxResults, executionQueryDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Executions (POST) Queries for executions that fulfill given parameters through a JSON object. This method is slightly more powerful than the [Get Executions](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query/) method because it allows to filter by multiple instance and execution variables of types &#x60;String&#x60;, &#x60;Number&#x60; or &#x60;Boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ExecutionDto&gt;)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<List<ExecutionDto>>> QueryExecutionsWithHttpInfoAsync(int? firstResult = default(int?), int? maxResults = default(int?), ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.Http.Api.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }
            localVarRequestOptions.Data = executionQueryDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<ExecutionDto>>("/execution", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryExecutions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Execution Count (POST) Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>CountResultDto</returns>
        public CountResultDto QueryExecutionsCount(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto))
        {
            Camunda.Http.Api.Client.ApiResponse<CountResultDto> localVarResponse = QueryExecutionsCountWithHttpInfo(executionQueryDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Execution Count (POST) Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        public Camunda.Http.Api.Client.ApiResponse<CountResultDto> QueryExecutionsCountWithHttpInfo(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto))
        {
            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = executionQueryDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<CountResultDto>("/execution/count", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryExecutionsCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Execution Count (POST) Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        public async System.Threading.Tasks.Task<CountResultDto> QueryExecutionsCountAsync(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.Http.Api.Client.ApiResponse<CountResultDto> localVarResponse = await QueryExecutionsCountWithHttpInfoAsync(executionQueryDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Execution Count (POST) Queries for the number of executions that fulfill given parameters. This method takes the same message body as the [Get Executions POST](https://docs.camunda.org/manual/latest/reference/rest/execution/post-query/) method and therefore it is slightly more powerful than the [Get Execution Count](https://docs.camunda.org/manual/latest/reference/rest/execution/get-query-count/) method.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="executionQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<CountResultDto>> QueryExecutionsCountWithHttpInfoAsync(ExecutionQueryDto executionQueryDto = default(ExecutionQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = executionQueryDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<CountResultDto>("/execution/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryExecutionsCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Post Local Execution Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns></returns>
        public void SetLocalExecutionVariableBinary(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string))
        {
            SetLocalExecutionVariableBinaryWithHttpInfo(id, varName, data, valueType);
        }

        /// <summary>
        /// Post Local Execution Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.Http.Api.Client.ApiResponse<Object> SetLocalExecutionVariableBinaryWithHttpInfo(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->SetLocalExecutionVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->SetLocalExecutionVariableBinary");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }
            if (valueType != null)
            {
                localVarRequestOptions.FormParameters.Add("valueType", Camunda.Http.Api.Client.ClientUtils.ParameterToString(valueType)); // form parameter
            }


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/execution/{id}/localVariables/{varName}/data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetLocalExecutionVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Post Local Execution Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetLocalExecutionVariableBinaryAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SetLocalExecutionVariableBinaryWithHttpInfoAsync(id, varName, data, valueType, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Post Local Execution Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable in the context of a given execution by id.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<Object>> SetLocalExecutionVariableBinaryWithHttpInfoAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->SetLocalExecutionVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'varName' when calling ExecutionApi->SetLocalExecutionVariableBinary");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }
            if (valueType != null)
            {
                localVarRequestOptions.FormParameters.Add("valueType", Camunda.Http.Api.Client.ClientUtils.ParameterToString(valueType)); // form parameter
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/execution/{id}/localVariables/{varName}/data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetLocalExecutionVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Trigger Execution Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns></returns>
        public void SignalExecution(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto))
        {
            SignalExecutionWithHttpInfo(id, executionTriggerDto);
        }

        /// <summary>
        /// Trigger Execution Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.Http.Api.Client.ApiResponse<Object> SignalExecutionWithHttpInfo(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->SignalExecution");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = executionTriggerDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/execution/{id}/signal", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignalExecution", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Trigger Execution Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SignalExecutionAsync(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SignalExecutionWithHttpInfoAsync(id, executionTriggerDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Trigger Execution Signals an execution by id. Can for example be used to explicitly skip user tasks or signal asynchronous continuations.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to signal.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<Object>> SignalExecutionWithHttpInfoAsync(string id, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->SignalExecution");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = executionTriggerDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/execution/{id}/signal", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignalExecution", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Trigger Message Event Subscription Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns></returns>
        public void TriggerEvent(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto))
        {
            TriggerEventWithHttpInfo(id, messageName, executionTriggerDto);
        }

        /// <summary>
        /// Trigger Message Event Subscription Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.Http.Api.Client.ApiResponse<Object> TriggerEventWithHttpInfo(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->TriggerEvent");

            // verify the required parameter 'messageName' is set
            if (messageName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'messageName' when calling ExecutionApi->TriggerEvent");

            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(messageName)); // path parameter
            localVarRequestOptions.Data = executionTriggerDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/execution/{id}/messageSubscriptions/{messageName}/trigger", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TriggerEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Trigger Message Event Subscription Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task TriggerEventAsync(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await TriggerEventWithHttpInfoAsync(id, messageName, executionTriggerDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Trigger Message Event Subscription Delivers a message to a specific execution by id, to trigger an existing message event subscription. Inject process variables as the message&#39;s payload.
        /// </summary>
        /// <exception cref="Camunda.Http.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the execution to submit the message to.</param>
        /// <param name="messageName">The name of the message that the addressed subscription corresponds to.</param>
        /// <param name="executionTriggerDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.Http.Api.Client.ApiResponse<Object>> TriggerEventWithHttpInfoAsync(string id, string messageName, ExecutionTriggerDto executionTriggerDto = default(ExecutionTriggerDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'id' when calling ExecutionApi->TriggerEvent");

            // verify the required parameter 'messageName' is set
            if (messageName == null)
                throw new Camunda.Http.Api.Client.ApiException(400, "Missing required parameter 'messageName' when calling ExecutionApi->TriggerEvent");


            Camunda.Http.Api.Client.RequestOptions localVarRequestOptions = new Camunda.Http.Api.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.Http.Api.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.Http.Api.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.Http.Api.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("messageName", Camunda.Http.Api.Client.ClientUtils.ParameterToString(messageName)); // path parameter
            localVarRequestOptions.Data = executionTriggerDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/execution/{id}/messageSubscriptions/{messageName}/trigger", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TriggerEvent", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
